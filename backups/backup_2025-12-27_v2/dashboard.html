<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Carbon IMS</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container dashboard-container">
        <div class="dashboard-box">
            <header class="home-header">
                <h1>Dashboard</h1>
                <div class="header-actions">
                    <a href="{{ url_for('home') }}" class="btn-secondary">Home</a>
                    <a href="{{ url_for('logout') }}" class="btn-logout">Logout</a>
                </div>
            </header>

            {% with messages = get_flashed_messages(with_categories=true) %}
                {% if messages %}
                    {% for category, message in messages %}
                        <div class="alert alert-{{ category }}">
                            {{ message }}
                        </div>
                    {% endfor %}
                {% endif %}
            {% endwith %}

            <div class="dashboard-quartiles">
                <!-- Cell 1: Pie Chart -->
                <div class="quartile" id="quartile-1">
                    <div class="quartile-header">
                        <h3>Inventory by Category</h3>
                        <div class="chart-controls">
                            <label for="groupBySelect">Group by:</label>
                            <select id="groupBySelect" onchange="updateChart(); saveDashboardSettings();">
                                <option value="Registry" selected>Registry</option>
                                <option value="Market">Market</option>
                                <option value="Product">Product</option>
                                <option value="ProjectType">Project Type</option>
                                <option value="Protocol">Protocol</option>
                                <option value="IsCustody">Custody Status</option>
                            </select>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="pieChart"></canvas>
                    </div>
                    <div class="chart-stats" id="chartStats">
                        <span class="stat-total">Total: <strong id="totalCount">0</strong> items</span>
                    </div>
                </div>

                <!-- Cell 2: Inventory Summary -->
                <div class="quartile" id="quartile-2">
                    <div class="quartile-header">
                        <h3>Inventory Summary</h3>
                        <div class="chart-controls">
                            <label for="summaryGroupBy">Group by:</label>
                            <select id="summaryGroupBy" onchange="updateSummaryView()">
                                <option value="Registry" selected>Registry</option>
                                <option value="Market">Market</option>
                                <option value="Product">Product</option>
                                <option value="ProjectType">Project Type</option>
                                <option value="Protocol">Protocol</option>
                                <option value="IsCustody">Custody Status</option>
                            </select>
                        </div>
                    </div>
                    <div class="quartile-content placeholder-content">
                        <div class="summary-stats" id="summaryStats">
                            <!-- Will be populated by JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- Cell 3: Quick Actions -->
                <div class="quartile" id="quartile-3">
                    <div class="quartile-header">
                        <h3>Quick Actions</h3>
                    </div>
                    <div class="quartile-content">
                        <div class="quick-actions">
                            <a href="{{ url_for('inventory') }}" class="action-btn">
                                <span class="action-icon">&#128230;</span>
                                <span>Manage Inventory</span>
                            </a>
                            <a href="{{ url_for('warranties') }}" class="action-btn">
                                <span class="action-icon">&#128196;</span>
                                <span>View Warranties</span>
                            </a>
                            {% if user_role == 'admin' %}
                            <a href="{{ url_for('manage_users') }}" class="action-btn">
                                <span class="action-icon">&#128101;</span>
                                <span>User Management</span>
                            </a>
                            {% endif %}
                            <a href="{{ url_for('settings') }}" class="action-btn">
                                <span class="action-icon">&#9881;</span>
                                <span>Settings</span>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Cell 4: Warranty Timeline Gantt Chart (spans 3 columns) -->
                <div class="quartile span-3" id="quartile-4">
                    <div class="quartile-header">
                        <h3>Warranty Timeline</h3>
                        <div class="gantt-controls">
                            <label>Group by:</label>
                            <div class="multi-select-wrapper" id="ganttGroupByWrapper">
                                <div class="multi-select-display" onclick="toggleFilterDropdown('ganttGroupByDropdown')">
                                    <span id="ganttGroupByText">Project ID</span>
                                    <span class="multi-select-arrow">&#9662;</span>
                                </div>
                                <div class="multi-select-dropdown" id="ganttGroupByDropdown">
                                    <div class="groupby-order-list" id="groupByOrderList">
                                        <!-- Ordered selected items will be displayed here -->
                                    </div>
                                    <div class="multi-select-actions">
                                        <button type="button" onclick="clearAllGroupBy()">Clear All</button>
                                    </div>
                                    <div class="multi-select-options" id="ganttGroupByOptions">
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_ProjectID" value="ProjectID" checked onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_ProjectID">Project ID</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Registry" value="Registry" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Registry">Registry</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Market" value="Market" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Market">Market</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Product" value="Product" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Product">Product</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_ProjectType" value="ProjectType" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_ProjectType">Project Type</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Protocol" value="Protocol" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Protocol">Protocol</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Buy_Client" value="Buy_Client" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Buy_Client">Buy Client</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Buy_TradeID" value="Buy_TradeID" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Buy_TradeID">Buy Trade ID</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Sell_Client" value="Sell_Client" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Sell_Client">Sell Client</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Sell_TradeID" value="Sell_TradeID" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Sell_TradeID">Sell Trade ID</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="gantt-filter-container">
                                <label for="ganttFilter">Filter:</label>
                                <div class="multi-select-wrapper" id="ganttFilterWrapper">
                                    <div class="multi-select-display" onclick="toggleFilterDropdown('ganttFilterDropdown')">
                                        <span id="ganttFilterText">All Items</span>
                                        <span class="multi-select-arrow">&#9662;</span>
                                    </div>
                                    <div class="multi-select-dropdown" id="ganttFilterDropdown">
                                        <div class="multi-select-actions">
                                            <button type="button" onclick="selectAllFilters()">Select All</button>
                                            <button type="button" onclick="clearAllFilters()">Clear All</button>
                                        </div>
                                        <div class="multi-select-options" id="ganttFilterOptions">
                                            <!-- Options populated dynamically -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="gantt-aggregate-toggle">
                                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; white-space: nowrap;">
                                    <input type="checkbox" id="aggregateBarsToggle" onchange="toggleAggregateBars()">
                                    <span>Aggregate Bars</span>
                                </label>
                            </div>
                            <button class="btn-fullscreen" onclick="openGanttFullscreen()" title="View fullscreen">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                                </svg>
                                Fullscreen
                            </button>
                        </div>
                    </div>
                    <div class="gantt-container" id="ganttContainer">
                        <div class="gantt-empty">Loading warranty data...</div>
                    </div>
                    <div class="gantt-legend">
                        <div class="legend-item">
                            <span class="legend-color active"></span>
                            <span>Active (>90 days)</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color expiring-90"></span>
                            <span>Expiring 90 days</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color expiring-30"></span>
                            <span>Expiring 30 days</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color expired"></span>
                            <span>Expired</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color buy-indicator"></span>
                            <span>Buy Warranty</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color sell-indicator"></span>
                            <span>Sell Warranty</span>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Credits Data Dialog -->
    <div class="credits-dialog-overlay" id="creditsDialogOverlay" onclick="closeCreditsDialog(event)">
        <div class="credits-dialog" onclick="event.stopPropagation()">
            <div class="credits-dialog-header">
                <div>
                    <h3 id="creditsDialogTitle">Credits Details</h3>
                    <div class="dialog-subtitle" id="creditsDialogSubtitle"></div>
                </div>
                <button class="credits-dialog-close" onclick="closeCreditsDialog()">&times;</button>
            </div>
            <div class="credits-dialog-body">
                <table class="credits-table">
                    <thead id="creditsDialogHead">
                        <tr>
                            <th>Serial Range</th>
                            <th>Count</th>
                            <th>Market</th>
                            <th>Registry</th>
                            <th>Product</th>
                            <th>Project ID</th>
                            <th>Project Name</th>
                            <th>Project Type</th>
                            <th>Protocol</th>
                            <th>Buy Start</th>
                            <th>Buy End</th>
                            <th>Buy Trade ID</th>
                            <th>Buy Client</th>
                            <th>Sell Start</th>
                            <th>Sell End</th>
                            <th>Sell Trade ID</th>
                            <th>Sell Client</th>
                        </tr>
                    </thead>
                    <tbody id="creditsDialogBody">
                    </tbody>
                </table>
            </div>
            <div class="credits-dialog-footer">
                <span class="credits-count">Total: <strong id="creditsDialogCount">0</strong> credits</span>
                <button class="btn-secondary" onclick="closeCreditsDialog()">Close</button>
            </div>
        </div>
    </div>

    <!-- Fullscreen Modal for Gantt Chart -->
    <div class="gantt-fullscreen-modal" id="ganttFullscreenModal">
        <div class="gantt-fullscreen-header">
            <h2>Warranty Timeline</h2>
            <div class="gantt-fullscreen-controls">
                <label>Group by:</label>
                <div class="multi-select-wrapper" id="ganttGroupByWrapperFullscreen">
                    <div class="multi-select-display" onclick="toggleFilterDropdown('ganttGroupByDropdownFullscreen')">
                        <span id="ganttGroupByTextFullscreen">Project ID</span>
                        <span class="multi-select-arrow">&#9662;</span>
                    </div>
                    <div class="multi-select-dropdown" id="ganttGroupByDropdownFullscreen">
                        <div class="groupby-order-list" id="groupByOrderListFullscreen">
                            <!-- Ordered selected items will be displayed here -->
                        </div>
                        <div class="multi-select-actions">
                            <button type="button" onclick="clearAllGroupByFullscreen()">Clear All</button>
                        </div>
                        <div class="multi-select-options" id="ganttGroupByOptionsFullscreen">
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_ProjectID" value="ProjectID" checked onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_ProjectID">Project ID</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Registry" value="Registry" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Registry">Registry</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Market" value="Market" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Market">Market</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Product" value="Product" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Product">Product</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_ProjectType" value="ProjectType" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_ProjectType">Project Type</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Protocol" value="Protocol" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Protocol">Protocol</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Buy_Client" value="Buy_Client" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Buy_Client">Buy Client</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Buy_TradeID" value="Buy_TradeID" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Buy_TradeID">Buy Trade ID</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Sell_Client" value="Sell_Client" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Sell_Client">Sell Client</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Sell_TradeID" value="Sell_TradeID" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Sell_TradeID">Sell Trade ID</label>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="gantt-filter-container">
                    <label for="ganttFilterFullscreen">Filter:</label>
                    <div class="multi-select-wrapper" id="ganttFilterWrapperFullscreen">
                        <div class="multi-select-display" onclick="toggleFilterDropdown('ganttFilterDropdownFullscreen')">
                            <span id="ganttFilterTextFullscreen">All Items</span>
                            <span class="multi-select-arrow">&#9662;</span>
                        </div>
                        <div class="multi-select-dropdown" id="ganttFilterDropdownFullscreen">
                            <div class="multi-select-actions">
                                <button type="button" onclick="selectAllFiltersFullscreen()">Select All</button>
                                <button type="button" onclick="clearAllFiltersFullscreen()">Clear All</button>
                            </div>
                            <div class="multi-select-options" id="ganttFilterOptionsFullscreen">
                                <!-- Options populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="gantt-aggregate-toggle">
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; white-space: nowrap;">
                        <input type="checkbox" id="aggregateBarsToggleFullscreen" onchange="toggleAggregateBarsFullscreen()">
                        <span>Aggregate Bars</span>
                    </label>
                </div>
                <button class="btn-close-fullscreen" onclick="closeGanttFullscreen()">Close</button>
            </div>
        </div>
        <div class="gantt-fullscreen-body" id="ganttFullscreenBody">
            <div class="gantt-empty">Loading warranty data...</div>
        </div>
        <div class="gantt-fullscreen-legend">
            <div class="legend-item">
                <span class="legend-color active"></span>
                <span>Active (>90 days)</span>
            </div>
            <div class="legend-item">
                <span class="legend-color expiring-90"></span>
                <span>Expiring 90 days</span>
            </div>
            <div class="legend-item">
                <span class="legend-color expiring-30"></span>
                <span>Expiring 30 days</span>
            </div>
            <div class="legend-item">
                <span class="legend-color expired"></span>
                <span>Expired</span>
            </div>
            <div class="legend-item">
                <span class="legend-color buy-indicator"></span>
                <span>Buy Warranty</span>
            </div>
            <div class="legend-item">
                <span class="legend-color sell-indicator"></span>
                <span>Sell Warranty</span>
            </div>
        </div>
    </div>

    <script>
        let pieChart = null;
        const chartColors = [
            '#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe',
            '#00f2fe', '#43e97b', '#38f9d7', '#fa709a', '#fee140',
            '#30cfd0', '#c779d0', '#feac5e', '#a8edea', '#fed6e3'
        ];

        async function fetchChartData(groupBy = 'Registry') {
            try {
                const response = await fetch(`/api/dashboard/stats?group_by=${groupBy}`);
                if (!response.ok) throw new Error('Failed to fetch data');
                return await response.json();
            } catch (error) {
                console.error('Error fetching chart data:', error);
                return null;
            }
        }

        function createPieChart(labels, values) {
            const ctx = document.getElementById('pieChart').getContext('2d');

            if (pieChart) {
                pieChart.destroy();
            }

            pieChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: chartColors.slice(0, labels.length),
                        borderColor: '#fff',
                        borderWidth: 2,
                        hoverOffset: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                padding: 15,
                                usePointStyle: true,
                                pointStyle: 'circle',
                                font: {
                                    size: 12,
                                    family: 'Roboto'
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                                    return `${context.label}: ${context.parsed} (${percentage}%)`;
                                }
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const label = pieChart.data.labels[index];
                            const value = pieChart.data.datasets[0].data[index];
                            showChartDetail(label, value);
                        }
                    }
                }
            });
        }

        function showChartDetail(label, value) {
            const groupBy = document.getElementById('groupBySelect').value;
            alert(`${groupBy}: ${label}\nCount: ${value} items`);
        }

        function updateSummaryStats(data) {
            const summaryContainer = document.getElementById('summaryStats');
            if (!data || !data.labels) {
                summaryContainer.innerHTML = '<p class="placeholder-text">No data available</p>';
                return;
            }

            let html = '';
            const groupBy = data.group_by;

            // Create summary cards for top categories
            const sortedData = data.labels.map((label, i) => ({
                label: label,
                value: data.values[i]
            })).sort((a, b) => b.value - a.value);

            const topItems = sortedData.slice(0, 5);

            html += `<div class="summary-header">Top ${groupBy} Categories</div>`;
            html += '<div class="summary-list">';

            topItems.forEach((item, index) => {
                const percentage = ((item.value / data.total) * 100).toFixed(1);
                html += `
                    <div class="summary-item">
                        <span class="summary-rank" style="background: ${chartColors[index]}">${index + 1}</span>
                        <span class="summary-label">${item.label}</span>
                        <span class="summary-value">${item.value} <small>(${percentage}%)</small></span>
                    </div>
                `;
            });

            html += '</div>';
            summaryContainer.innerHTML = html;
        }

        async function updateSummaryView() {
            const groupBy = document.getElementById('summaryGroupBy').value;
            const data = await fetchChartData(groupBy);

            if (data && data.labels) {
                updateSummaryStats(data);
            }
        }

        async function updateChart() {
            const groupBy = document.getElementById('groupBySelect').value;
            const data = await fetchChartData(groupBy);

            if (data && data.labels) {
                createPieChart(data.labels, data.values);
                document.getElementById('totalCount').textContent = data.total;
                updateSummaryStats(data);
            }
        }

        // Dashboard Settings Persistence
        async function loadDashboardSettings() {
            try {
                const response = await fetch('/api/settings/dashboard');
                if (!response.ok) return {};
                const data = await response.json();
                return data.settings || {};
            } catch (error) {
                console.error('Error loading dashboard settings:', error);
                return {};
            }
        }

        async function saveDashboardSettings() {
            try {
                const settings = collectCurrentSettings();
                await fetch('/api/settings/dashboard', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
            } catch (error) {
                console.error('Error saving dashboard settings:', error);
            }
        }

        function collectCurrentSettings() {
            const settings = {};

            // Inventory Summary group by
            const inventoryGroupBy = document.getElementById('groupBySelect');
            if (inventoryGroupBy) {
                settings.inventoryGroupBy = inventoryGroupBy.value;
            }

            // Gantt chart group by - save the ordered array
            settings.ganttGroupBy = [...groupByOrder];

            // Gantt chart filters
            const filterCheckboxes = document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]');
            settings.ganttFilters = [];
            filterCheckboxes.forEach(cb => {
                if (cb.checked) {
                    settings.ganttFilters.push(decodeURIComponent(cb.value));
                }
            });

            // Aggregate bars toggle
            settings.aggregateBars = aggregateBarsMode;

            return settings;
        }

        function applySettings(settings) {
            if (!settings || Object.keys(settings).length === 0) {
                // No settings - render initial order list
                renderGroupByOrderList(false);
                return;
            }

            // Apply inventory group by
            if (settings.inventoryGroupBy) {
                const inventoryGroupBy = document.getElementById('groupBySelect');
                if (inventoryGroupBy) {
                    inventoryGroupBy.value = settings.inventoryGroupBy;
                }
            }

            // Apply gantt group by - restore the ordered array
            if (settings.ganttGroupBy && Array.isArray(settings.ganttGroupBy) && settings.ganttGroupBy.length > 0) {
                groupByOrder = [...settings.ganttGroupBy];
                document.querySelectorAll('#ganttGroupByOptions input[type="checkbox"]').forEach(cb => {
                    cb.checked = groupByOrder.includes(cb.value);
                });
                renderGroupByOrderList(false);
                updateGroupByText();
            } else {
                // No saved settings - render initial order list
                renderGroupByOrderList(false);
            }

            // Apply aggregate bars toggle
            if (settings.aggregateBars !== undefined) {
                aggregateBarsMode = settings.aggregateBars;
                document.getElementById('aggregateBarsToggle').checked = aggregateBarsMode;
                document.getElementById('aggregateBarsToggleFullscreen').checked = aggregateBarsMode;
            }
        }

        function applyFiltersAfterLoad(settings) {
            // Apply gantt filters after data is loaded
            // Only apply filters that exist in the current data options
            if (settings.ganttFilters && Array.isArray(settings.ganttFilters) && settings.ganttFilters.length > 0) {
                const availableFilters = new Set();
                document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                    availableFilters.add(decodeURIComponent(cb.value));
                });

                // Check if any saved filters match current options
                const matchingFilters = settings.ganttFilters.filter(f => availableFilters.has(f));

                if (matchingFilters.length > 0) {
                    selectedFilters.clear();
                    document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                        const label = decodeURIComponent(cb.value);
                        if (matchingFilters.includes(label)) {
                            cb.checked = true;
                            selectedFilters.add(label);
                        } else {
                            cb.checked = false;
                        }
                    });
                    updateFilterText(false);
                    applyFilterAndRender();
                }
                // If no matching filters, keep all selected (default behavior from populateFilterOptions)
            }
        }

        // Store loaded settings for use after data loads
        let loadedSettings = {};

        // Initialize chart on page load
        document.addEventListener('DOMContentLoaded', async function() {
            // Load saved settings first
            loadedSettings = await loadDashboardSettings();

            // Apply settings to UI elements
            applySettings(loadedSettings);

            // Then load charts
            updateChart();
            await updateGanttChart();

            // Apply filters after chart data is loaded
            if (loadedSettings.ganttFilters) {
                applyFiltersAfterLoad(loadedSettings);
            }
        });

        // Gantt Chart Functions
        async function fetchGanttData(groupBy = 'ProjectID') {
            try {
                const response = await fetch(`/api/dashboard/warranty-gantt?group_by=${groupBy}`);
                if (!response.ok) throw new Error('Failed to fetch data');
                return await response.json();
            } catch (error) {
                console.error('Error fetching Gantt data:', error);
                return null;
            }
        }

        function parseDate(dateStr) {
            if (!dateStr) return null;
            // Try YYYY-MM-DD format
            let date = new Date(dateStr);
            if (!isNaN(date.getTime())) return date;
            // Try MM/DD/YYYY format
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                date = new Date(parts[2], parts[0] - 1, parts[1]);
                if (!isNaN(date.getTime())) return date;
            }
            return null;
        }

        // Store warranty data for dialog
        let cachedWarrantyData = null;
        let cachedGanttDataMain = null;
        let selectedFilters = new Set();
        let selectedFiltersFullscreen = new Set();
        let aggregateBarsMode = false;

        // Ordered arrays for group by fields (maintains user-specified order)
        let groupByOrder = ['ProjectID'];  // Default order
        let groupByOrderFullscreen = ['ProjectID'];

        // Group By multi-select functions
        function getSelectedGroupByFields(isFullscreen = false) {
            // Return the ordered array instead of reading from DOM
            return isFullscreen ? [...groupByOrderFullscreen] : [...groupByOrder];
        }

        function setGroupByOrder(order, isFullscreen = false) {
            if (isFullscreen) {
                groupByOrderFullscreen = [...order];
            } else {
                groupByOrder = [...order];
            }
        }

        function updateGroupByText() {
            const selected = getSelectedGroupByFields(false);
            const textEl = document.getElementById('ganttGroupByText');
            if (selected.length === 0) {
                textEl.textContent = 'Select fields...';
            } else if (selected.length <= 2) {
                textEl.textContent = selected.map(f => getFieldDisplayName(f)).join(' > ');
            } else {
                textEl.textContent = `${selected.length} levels`;
            }
        }

        function updateGroupByTextFullscreen() {
            const selected = getSelectedGroupByFields(true);
            const textEl = document.getElementById('ganttGroupByTextFullscreen');
            if (selected.length === 0) {
                textEl.textContent = 'Select fields...';
            } else if (selected.length <= 2) {
                textEl.textContent = selected.map(f => getFieldDisplayName(f)).join(' > ');
            } else {
                textEl.textContent = `${selected.length} levels`;
            }
        }

        function getFieldDisplayName(field) {
            const names = {
                'ProjectID': 'Project ID',
                'Registry': 'Registry',
                'Market': 'Market',
                'Product': 'Product',
                'ProjectType': 'Project Type',
                'Protocol': 'Protocol',
                'Buy_Client': 'Buy Client',
                'Sell_Client': 'Sell Client',
                'Buy_TradeID': 'Buy Trade ID',
                'Sell_TradeID': 'Sell Trade ID'
            };
            return names[field] || field;
        }

        // Render the ordered list of selected fields
        function renderGroupByOrderList(isFullscreen = false) {
            const order = isFullscreen ? groupByOrderFullscreen : groupByOrder;
            const listId = isFullscreen ? 'groupByOrderListFullscreen' : 'groupByOrderList';
            const listEl = document.getElementById(listId);

            if (order.length === 0) {
                listEl.innerHTML = '';
                return;
            }

            listEl.innerHTML = order.map((field, idx) => `
                <div class="groupby-order-item" draggable="true" data-field="${field}" data-index="${idx}">
                    <span class="groupby-order-num">${idx + 1}</span>
                    <span class="groupby-order-name">${getFieldDisplayName(field)}</span>
                    <div class="groupby-order-controls">
                        <button class="groupby-order-btn" onclick="moveGroupByField(${idx}, -1, ${isFullscreen})" ${idx === 0 ? 'disabled' : ''} title="Move up">&#9650;</button>
                        <button class="groupby-order-btn" onclick="moveGroupByField(${idx}, 1, ${isFullscreen})" ${idx === order.length - 1 ? 'disabled' : ''} title="Move down">&#9660;</button>
                        <button class="groupby-order-btn remove" onclick="removeGroupByField('${field}', ${isFullscreen})" title="Remove">&times;</button>
                    </div>
                </div>
            `).join('');

            // Add drag and drop event listeners
            setupDragAndDrop(listEl, isFullscreen);
        }

        function setupDragAndDrop(listEl, isFullscreen) {
            const items = listEl.querySelectorAll('.groupby-order-item');
            let draggedItem = null;
            let draggedIndex = null;

            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedItem = item;
                    draggedIndex = parseInt(item.dataset.index);
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    items.forEach(i => i.classList.remove('drag-over'));
                    draggedItem = null;
                    draggedIndex = null;
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    if (item !== draggedItem) {
                        item.classList.add('drag-over');
                    }
                });

                item.addEventListener('dragleave', () => {
                    item.classList.remove('drag-over');
                });

                item.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');

                    const dropIndex = parseInt(item.dataset.index);
                    if (draggedIndex !== null && draggedIndex !== dropIndex) {
                        const order = isFullscreen ? groupByOrderFullscreen : groupByOrder;
                        const [movedField] = order.splice(draggedIndex, 1);
                        order.splice(dropIndex, 0, movedField);

                        renderGroupByOrderList(isFullscreen);
                        if (isFullscreen) {
                            updateGroupByTextFullscreen();
                            await onGroupByChangeFullscreen();
                            syncFromFullscreen();
                        } else {
                            updateGroupByText();
                            await onGroupByChange();
                        }
                        saveDashboardSettings();
                    }
                });
            });
        }

        async function moveGroupByField(index, direction, isFullscreen = false) {
            const order = isFullscreen ? groupByOrderFullscreen : groupByOrder;
            const newIndex = index + direction;

            if (newIndex < 0 || newIndex >= order.length) return;

            // Swap elements
            [order[index], order[newIndex]] = [order[newIndex], order[index]];

            renderGroupByOrderList(isFullscreen);
            if (isFullscreen) {
                updateGroupByTextFullscreen();
                await onGroupByChangeFullscreen();
                syncFromFullscreen();
            } else {
                updateGroupByText();
                await onGroupByChange();
            }
            saveDashboardSettings();
        }

        async function removeGroupByField(field, isFullscreen = false) {
            const order = isFullscreen ? groupByOrderFullscreen : groupByOrder;
            const idx = order.indexOf(field);
            if (idx > -1) {
                order.splice(idx, 1);
            }

            // Uncheck the checkbox
            const checkboxId = isFullscreen ? `groupby_fs_${field}` : `groupby_${field}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) checkbox.checked = false;

            renderGroupByOrderList(isFullscreen);
            if (isFullscreen) {
                updateGroupByTextFullscreen();
                await onGroupByChangeFullscreen();
                syncFromFullscreen();
            } else {
                updateGroupByText();
                await onGroupByChange();
            }
            saveDashboardSettings();
        }

        function syncFromFullscreen() {
            // Sync order from fullscreen to main
            groupByOrder = [...groupByOrderFullscreen];

            // Sync checkboxes
            document.querySelectorAll('#ganttGroupByOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = groupByOrder.includes(cb.value);
            });

            renderGroupByOrderList(false);
            updateGroupByText();
        }

        async function clearAllGroupBy() {
            groupByOrder = [];
            document.querySelectorAll('#ganttGroupByOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            renderGroupByOrderList(false);
            updateGroupByText();
            await onGroupByChange();
            saveDashboardSettings();
        }

        async function clearAllGroupByFullscreen() {
            groupByOrderFullscreen = [];
            document.querySelectorAll('#ganttGroupByOptionsFullscreen input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            renderGroupByOrderList(true);
            updateGroupByTextFullscreen();
            await onGroupByChangeFullscreen();
            syncFromFullscreen();
            saveDashboardSettings();
        }

        async function onGroupByCheckboxChange(event) {
            const checkbox = event ? event.target : null;
            if (checkbox) {
                const field = checkbox.value;
                if (checkbox.checked) {
                    // Add to end of order if not already present
                    if (!groupByOrder.includes(field)) {
                        groupByOrder.push(field);
                    }
                } else {
                    // Remove from order
                    const idx = groupByOrder.indexOf(field);
                    if (idx > -1) {
                        groupByOrder.splice(idx, 1);
                    }
                }
            }

            renderGroupByOrderList(false);
            updateGroupByText();
            await onGroupByChange();
            saveDashboardSettings();
        }

        async function onGroupByCheckboxChangeFullscreen(event) {
            const checkbox = event ? event.target : null;
            if (checkbox) {
                const field = checkbox.value;
                if (checkbox.checked) {
                    // Add to end of order if not already present
                    if (!groupByOrderFullscreen.includes(field)) {
                        groupByOrderFullscreen.push(field);
                    }
                } else {
                    // Remove from order
                    const idx = groupByOrderFullscreen.indexOf(field);
                    if (idx > -1) {
                        groupByOrderFullscreen.splice(idx, 1);
                    }
                }
            }

            renderGroupByOrderList(true);
            updateGroupByTextFullscreen();
            await onGroupByChangeFullscreen();
            syncFromFullscreen();
            saveDashboardSettings();
        }

        // Filter dropdown functions
        function toggleFilterDropdown(dropdownId) {
            const dropdown = document.getElementById(dropdownId);
            const isActive = dropdown.classList.contains('active');

            // Close all dropdowns first
            document.querySelectorAll('.multi-select-dropdown').forEach(d => d.classList.remove('active'));

            if (!isActive) {
                dropdown.classList.add('active');
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.multi-select-wrapper')) {
                document.querySelectorAll('.multi-select-dropdown').forEach(d => d.classList.remove('active'));
            }
        });

        function populateFilterOptions(data, isFullscreen = false) {
            const optionsContainer = document.getElementById(isFullscreen ? 'ganttFilterOptionsFullscreen' : 'ganttFilterOptions');
            const filterTextEl = document.getElementById(isFullscreen ? 'ganttFilterTextFullscreen' : 'ganttFilterText');
            const filterSet = isFullscreen ? selectedFiltersFullscreen : selectedFilters;

            if (!data || !data.items || data.items.length === 0) {
                optionsContainer.innerHTML = '<div style="padding: 10px; color: #999;">No items available</div>';
                return;
            }

            // Get unique labels
            const uniqueLabels = [...new Set(data.items.map(item => item.label))].sort();

            // Clear and reset filters if group changed
            filterSet.clear();
            uniqueLabels.forEach(label => filterSet.add(label));

            // Build options HTML
            optionsContainer.innerHTML = uniqueLabels.map(label => `
                <div class="multi-select-option">
                    <input type="checkbox" id="${isFullscreen ? 'fs_' : ''}filter_${encodeURIComponent(label)}"
                           value="${encodeURIComponent(label)}" checked
                           onchange="${isFullscreen ? 'onFilterChangeFullscreen' : 'onFilterChange'}(this)">
                    <label for="${isFullscreen ? 'fs_' : ''}filter_${encodeURIComponent(label)}">${label}</label>
                </div>
            `).join('');

            updateFilterText(isFullscreen);
        }

        function onFilterChange(checkbox) {
            const label = decodeURIComponent(checkbox.value);
            if (checkbox.checked) {
                selectedFilters.add(label);
            } else {
                selectedFilters.delete(label);
            }
            updateFilterText(false);
            applyFilterAndRender();
            saveDashboardSettings();
        }

        function onFilterChangeFullscreen(checkbox) {
            const label = decodeURIComponent(checkbox.value);
            if (checkbox.checked) {
                selectedFiltersFullscreen.add(label);
            } else {
                selectedFiltersFullscreen.delete(label);
            }
            updateFilterText(true);
            applyFilterAndRenderFullscreen();
            // Sync back to main and save
            selectedFilters = new Set(selectedFiltersFullscreen);
            document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                const cbLabel = decodeURIComponent(cb.value);
                cb.checked = selectedFilters.has(cbLabel);
            });
            updateFilterText(false);
            saveDashboardSettings();
        }

        function updateFilterText(isFullscreen) {
            const filterTextEl = document.getElementById(isFullscreen ? 'ganttFilterTextFullscreen' : 'ganttFilterText');
            const filterSet = isFullscreen ? selectedFiltersFullscreen : selectedFilters;
            const optionsContainer = document.getElementById(isFullscreen ? 'ganttFilterOptionsFullscreen' : 'ganttFilterOptions');
            const totalOptions = optionsContainer.querySelectorAll('input[type="checkbox"]').length;

            if (filterSet.size === 0) {
                filterTextEl.textContent = 'None Selected';
            } else if (filterSet.size === totalOptions) {
                filterTextEl.textContent = 'All Items';
            } else if (filterSet.size <= 2) {
                filterTextEl.textContent = [...filterSet].join(', ');
            } else {
                filterTextEl.textContent = `${filterSet.size} selected`;
            }
        }

        function selectAllFilters() {
            document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
                selectedFilters.add(decodeURIComponent(cb.value));
            });
            updateFilterText(false);
            applyFilterAndRender();
            saveDashboardSettings();
        }

        function clearAllFilters() {
            document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            selectedFilters.clear();
            updateFilterText(false);
            applyFilterAndRender();
            saveDashboardSettings();
        }

        function selectAllFiltersFullscreen() {
            document.querySelectorAll('#ganttFilterOptionsFullscreen input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
                selectedFiltersFullscreen.add(decodeURIComponent(cb.value));
            });
            updateFilterText(true);
            applyFilterAndRenderFullscreen();
            // Sync back to main
            selectedFilters = new Set(selectedFiltersFullscreen);
            document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            saveDashboardSettings();
        }

        function clearAllFiltersFullscreen() {
            document.querySelectorAll('#ganttFilterOptionsFullscreen input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            selectedFiltersFullscreen.clear();
            updateFilterText(true);
            applyFilterAndRenderFullscreen();
            // Sync back to main
            selectedFilters.clear();
            document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            saveDashboardSettings();
        }

        function applyFilterAndRender() {
            if (!cachedGanttDataMain) return;

            const filteredData = {
                ...cachedGanttDataMain,
                items: cachedGanttDataMain.items.filter(item => selectedFilters.has(item.label))
            };
            renderGanttChart(filteredData);
        }

        function applyFilterAndRenderFullscreen() {
            if (!cachedGanttDataMain) return;

            const filteredData = {
                ...cachedGanttDataMain,
                items: cachedGanttDataMain.items.filter(item => selectedFiltersFullscreen.has(item.label))
            };
            renderGanttChartFullscreen(filteredData);
        }

        function toggleAggregateBars() {
            aggregateBarsMode = document.getElementById('aggregateBarsToggle').checked;
            // Sync fullscreen toggle
            document.getElementById('aggregateBarsToggleFullscreen').checked = aggregateBarsMode;
            applyFilterAndRender();
            saveDashboardSettings();
        }

        function toggleAggregateBarsFullscreen() {
            aggregateBarsMode = document.getElementById('aggregateBarsToggleFullscreen').checked;
            // Sync main toggle
            document.getElementById('aggregateBarsToggle').checked = aggregateBarsMode;
            applyFilterAndRenderFullscreen();
            saveDashboardSettings();
        }

        function aggregateItems(items) {
            // Group items by period_type (buy/sell)
            const buyItems = items.filter(item => item.period_type === 'buy' || !item.period_type);
            const sellItems = items.filter(item => item.period_type === 'sell');

            const aggregated = [];
            const label = items.length > 0 ? items[0].label : '';

            let buyStart = null, buyEnd = null;
            let sellStart = null, sellEnd = null;

            // Aggregate buy items
            if (buyItems.length > 0) {
                let earliestStart = null;
                let latestEnd = null;
                let totalVolume = 0;

                buyItems.forEach(item => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);

                    if (startDate && (!earliestStart || startDate < earliestStart)) {
                        earliestStart = startDate;
                    }
                    if (endDate && (!latestEnd || endDate > latestEnd)) {
                        latestEnd = endDate;
                    }
                    totalVolume += parseInt(item.volume) || 0;
                });

                if (earliestStart && latestEnd) {
                    buyStart = earliestStart;
                    buyEnd = latestEnd;

                    // Determine status based on latestEnd
                    const today = new Date();
                    const daysUntilExpiry = Math.ceil((latestEnd - today) / (1000 * 60 * 60 * 24));
                    let status = 'active';
                    if (daysUntilExpiry <= 30) status = 'expiring-30';
                    else if (daysUntilExpiry <= 60) status = 'expiring-60';
                    else if (daysUntilExpiry <= 90) status = 'expiring-90';

                    aggregated.push({
                        label: label,
                        start: earliestStart.toISOString().split('T')[0],
                        end: latestEnd.toISOString().split('T')[0],
                        volume: totalVolume,
                        status: status,
                        period_type: 'buy',
                        serial_group: 0
                    });
                }
            }

            // Aggregate sell items
            if (sellItems.length > 0) {
                let earliestStart = null;
                let latestEnd = null;
                let totalVolume = 0;

                sellItems.forEach(item => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);

                    if (startDate && (!earliestStart || startDate < earliestStart)) {
                        earliestStart = startDate;
                    }
                    if (endDate && (!latestEnd || endDate > latestEnd)) {
                        latestEnd = endDate;
                    }
                    totalVolume += parseInt(item.volume) || 0;
                });

                if (earliestStart && latestEnd) {
                    sellStart = earliestStart;
                    sellEnd = latestEnd;

                    // Determine status based on latestEnd
                    const today = new Date();
                    const daysUntilExpiry = Math.ceil((latestEnd - today) / (1000 * 60 * 60 * 24));
                    let status = 'active';
                    if (daysUntilExpiry <= 30) status = 'expiring-30';
                    else if (daysUntilExpiry <= 60) status = 'expiring-60';
                    else if (daysUntilExpiry <= 90) status = 'expiring-90';

                    // Check if buy and sell bars overlap
                    // Overlap occurs if: buyStart <= sellEnd AND sellStart <= buyEnd
                    let sellSerialGroup = 0;
                    if (buyStart && buyEnd && sellStart && sellEnd) {
                        const barsOverlap = (buyStart <= sellEnd) && (sellStart <= buyEnd);
                        if (barsOverlap) {
                            sellSerialGroup = 1; // Put sell on separate row if overlapping
                        }
                    }

                    aggregated.push({
                        label: label,
                        start: earliestStart.toISOString().split('T')[0],
                        end: latestEnd.toISOString().split('T')[0],
                        volume: totalVolume,
                        status: status,
                        period_type: 'sell',
                        serial_group: sellSerialGroup
                    });
                }
            }

            return aggregated;
        }

        async function onGroupByChange() {
            let groupByFields = getSelectedGroupByFields(false);
            if (groupByFields.length === 0) {
                document.getElementById('ganttContainer').innerHTML =
                    '<div class="gantt-empty">Please select at least one grouping field</div>';
                return;
            }
            const groupBy = groupByFields.join(',');

            try {
                const data = await fetchGanttData(groupBy);

                if (data) {
                    cachedGanttDataMain = data;
                    populateFilterOptions(data, false);
                    renderGanttChart(data);
                } else {
                    document.getElementById('ganttContainer').innerHTML =
                        '<div class="gantt-empty">No warranty data available</div>';
                }
            } catch (error) {
                console.error('Error in onGroupByChange:', error);
                document.getElementById('ganttContainer').innerHTML =
                    '<div class="gantt-empty">Error loading warranty data</div>';
            }
        }

        async function onGroupByChangeFullscreen() {
            let groupByFields = getSelectedGroupByFields(true);
            if (groupByFields.length === 0) {
                document.getElementById('ganttFullscreenBody').innerHTML =
                    '<div class="gantt-empty">Please select at least one grouping field</div>';
                return;
            }
            const groupBy = groupByFields.join(',');

            try {
                const data = await fetchGanttData(groupBy);

                if (data) {
                    cachedGanttDataMain = data;
                    populateFilterOptions(data, true);
                    renderGanttChartFullscreen(data);
                } else {
                    document.getElementById('ganttFullscreenBody').innerHTML =
                        '<div class="gantt-empty">No warranty data available</div>';
                }
            } catch (error) {
                console.error('Error in onGroupByChangeFullscreen:', error);
                document.getElementById('ganttFullscreenBody').innerHTML =
                    '<div class="gantt-empty">Error loading warranty data</div>';
            }
        }

        function calculateWeightedAvgDate(items, minDate, totalDays) {
            let totalWeight = 0;
            let weightedSum = 0;

            items.forEach(item => {
                const startDate = parseDateUTC(item.start);
                const endDate = parseDateUTC(item.end);

                if (startDate && endDate) {
                    // Calculate midpoint of warranty period
                    const midpoint = new Date((startDate.getTime() + endDate.getTime()) / 2);
                    const dayOffset = Math.round((midpoint - minDate) / (1000 * 60 * 60 * 24));

                    weightedSum += dayOffset * item.volume;
                    totalWeight += item.volume;
                }
            });

            if (totalWeight === 0) return null;

            const avgDayOffset = weightedSum / totalWeight;
            return (avgDayOffset / totalDays) * 100;
        }

        // Helper to parse date string to UTC date (avoiding timezone issues)
        function parseDateUTC(dateStr) {
            if (!dateStr) return null;
            // Handle YYYY-MM-DD format (with 1 or 2 digit month/day)
            const match = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})/);
            if (match) {
                return new Date(Date.UTC(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3])));
            }
            // Handle MM/DD/YYYY format
            const match2 = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
            if (match2) {
                return new Date(Date.UTC(parseInt(match2[3]), parseInt(match2[1]) - 1, parseInt(match2[2])));
            }
            return null;
        }

        function renderGanttChart(data) {
            const container = document.getElementById('ganttContainer');
            cachedWarrantyData = data;

            if (!data || !data.items || data.items.length === 0) {
                container.innerHTML = '<div class="gantt-empty">No warranty data available</div>';
                return;
            }

            // Parse dates as UTC to avoid timezone issues
            const minDate = parseDateUTC(data.min_date);
            const maxDate = parseDateUTC(data.max_date);
            const today = parseDateUTC(data.today);

            if (!minDate || !maxDate) {
                container.innerHTML = '<div class="gantt-empty">Invalid date range</div>';
                return;
            }

            // Calculate total time span in days
            const totalDays = Math.round((maxDate - minDate) / (1000 * 60 * 60 * 24));

            // Generate month markers with their day counts and percentages
            const months = [];
            let currentYear = minDate.getUTCFullYear();
            let currentMonthNum = minDate.getUTCMonth();

            while (true) {
                const monthStart = new Date(Date.UTC(currentYear, currentMonthNum, 1));
                const nextMonthStart = new Date(Date.UTC(currentYear, currentMonthNum + 1, 1));

                if (monthStart >= maxDate) break;

                const effectiveStart = monthStart < minDate ? minDate : monthStart;
                const effectiveEnd = nextMonthStart > maxDate ? maxDate : nextMonthStart;
                const daysInThisMonth = Math.round((effectiveEnd - effectiveStart) / (1000 * 60 * 60 * 24));
                const widthPercent = (daysInThisMonth / totalDays) * 100;

                months.push({
                    date: monthStart,
                    label: monthStart.toLocaleDateString('en-US', { month: 'short', year: '2-digit', timeZone: 'UTC' }),
                    days: daysInThisMonth,
                    widthPercent: widthPercent
                });

                currentMonthNum++;
                if (currentMonthNum > 11) {
                    currentMonthNum = 0;
                    currentYear++;
                }
            }

            // Generate month lines HTML for rows with proper widths
            const monthLinesHtml = '<div class="gantt-month-lines">' +
                months.map(m => `<div class="gantt-month-line" style="flex: 0 0 ${m.widthPercent}%; width: ${m.widthPercent}%;"></div>`).join('') +
                '</div>';

            // Generate body-level month lines with proper widths
            const bodyMonthLinesHtml = '<div class="gantt-body-month-lines">' +
                months.map(m => `<div class="gantt-body-month-line" style="flex: 0 0 ${m.widthPercent}%; width: ${m.widthPercent}%;"></div>`).join('') +
                '</div>';

            // Group items by label for display
            const groupedItems = {};
            data.items.forEach(item => {
                if (!groupedItems[item.label]) {
                    groupedItems[item.label] = [];
                }
                groupedItems[item.label].push(item);
            });

            // Build HTML
            let html = '<div class="gantt-chart">';

            // Header with months - use proportional widths
            html += '<div class="gantt-header">';
            html += '<div class="gantt-label-header">Item</div>';
            html += '<div class="gantt-timeline-header">';
            months.forEach(month => {
                html += `<div class="gantt-month" style="flex: 0 0 ${month.widthPercent}%; width: ${month.widthPercent}%;">${month.label}</div>`;
            });
            html += '</div></div>';

            // Body with rows
            html += '<div class="gantt-body">';
            html += bodyMonthLinesHtml;

            Object.keys(groupedItems).sort().forEach(label => {
                // Apply aggregation if enabled
                const items = aggregateBarsMode ? aggregateItems(groupedItems[label]) : groupedItems[label];

                // Calculate weighted average date for this group
                const avgPercent = calculateWeightedAvgDate(items, minDate, totalDays);

                // Assign bars to rows - non-overlapping bars share the same row
                const barHeight = 20;
                const barGap = 0;
                const topPadding = 0;
                const bottomPadding = 0;

                // Use serial_group directly as row number (Buy and Sell from same warranty share same serial_group)
                const itemRows = [];
                let maxRow = 0;

                items.forEach((item, idx) => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);
                    if (startDate && endDate && startDate <= endDate) {
                        // Use serial_group directly as row number - same as fullscreen version
                        const row = typeof item.serial_group === 'number' ? item.serial_group : idx;
                        itemRows[idx] = row;
                        if (row > maxRow) maxRow = row;
                    } else {
                        itemRows[idx] = -1;
                    }
                });

                const numRows = maxRow + 1;
                const rowTimelineHeight = numRows * barHeight;

                html += `<div class="gantt-row">`;
                html += `<div class="gantt-row-label" title="${label}">${label}</div>`;
                html += `<div class="gantt-row-timeline" style="height: ${rowTimelineHeight}px; position: relative;">`;
                html += monthLinesHtml;

                items.forEach((item, idx) => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);
                    const dataAttrs = `data-label="${encodeURIComponent(label)}" data-start="${item.start || ''}" data-end="${item.end || ''}" data-volume="${item.volume}"`;

                    if (startDate && endDate && startDate <= endDate && itemRows[idx] >= 0) {
                        // Calculate position and width using UTC dates
                        const startOffset = Math.round((startDate - minDate) / (1000 * 60 * 60 * 24));
                        const endOffset = Math.round((endDate - minDate) / (1000 * 60 * 60 * 24)) + 1;

                        const leftPercent = (startOffset / totalDays) * 100;
                        const widthPercent = ((endOffset - startOffset) / totalDays) * 100;

                        // Calculate top position based on assigned row
                        const topPosition = itemRows[idx] * barHeight;

                        // Create tooltip text
                        const periodLabel = item.period_type === 'sell' ? 'Sell' : 'Buy';
                        const tooltipText = `${label}\n${periodLabel} Warranty\nStart: ${item.start}\nEnd: ${item.end}\nVolume: ${item.volume}\nClick to view credits`;

                        const aggregateSellStyle = (aggregateBarsMode && item.period_type === 'sell') ? ' padding: 0;' : '';
                        html += `<div class="gantt-bar ${item.status} ${item.period_type || 'buy'}"
                            style="left: ${leftPercent}%; width: ${widthPercent}%; top: ${topPosition}px;${aggregateSellStyle}"
                            title="${tooltipText}" ${dataAttrs} data-period-type="${item.period_type || 'buy'}"
                            onclick="showCreditsDialog(this)">${item.volume}</div>`;
                    }
                });

                html += '</div>'; // Close timeline

                // Add weighted average line (positioned relative to row, after 150px label)
                if (avgPercent !== null && avgPercent >= 0 && avgPercent <= 100) {
                    html += `<div class="gantt-avg-line" style="left: calc(150px + (100% - 150px) * ${avgPercent / 100});" title="Weighted avg warranty date"></div>`;
                }

                html += '</div>'; // Close row
            });

            // Add today line - position relative to timeline area (after 150px label)
            // Add +1 day to align with end of bars that end today (same logic as bar endOffset)
            if (today) {
                const todayOffset = Math.round((today - minDate) / (1000 * 60 * 60 * 24)) + 1;
                const todayPercent = (todayOffset / totalDays) * 100;
                if (todayPercent >= 0 && todayPercent <= 100) {
                    html += `<div class="gantt-today-line" style="left: calc(150px + (100% - 150px) * ${todayPercent / 100})" title="Today"></div>`;
                }
            }

            html += '</div></div>';

            container.innerHTML = html;
        }

        async function updateGanttChart() {
            let groupByFields = getSelectedGroupByFields(false);
            // Default to ProjectID if nothing selected
            if (groupByFields.length === 0) {
                groupByFields = ['ProjectID'];
            }
            const groupBy = groupByFields.join(',');

            try {
                const data = await fetchGanttData(groupBy);

                if (data) {
                    cachedGanttDataMain = data;
                    populateFilterOptions(data, false);
                    renderGanttChart(data);
                } else {
                    document.getElementById('ganttContainer').innerHTML =
                        '<div class="gantt-empty">No warranty data available</div>';
                }
            } catch (error) {
                console.error('Error in updateGanttChart:', error);
                document.getElementById('ganttContainer').innerHTML =
                    '<div class="gantt-empty">Error loading warranty data</div>';
            }
        }

        // Fullscreen Gantt Chart Functions
        let cachedGanttData = null;

        function openGanttFullscreen() {
            const modal = document.getElementById('ganttFullscreenModal');
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';

            // Sync the group by order and selections from main view
            groupByOrderFullscreen = [...groupByOrder];
            const mainGroupByFields = getSelectedGroupByFields(false);
            document.querySelectorAll('#ganttGroupByOptionsFullscreen input[type="checkbox"]').forEach(cb => {
                cb.checked = mainGroupByFields.includes(cb.value);
            });
            renderGroupByOrderList(true);
            updateGroupByTextFullscreen();

            // Sync filters from main view
            if (cachedGanttDataMain) {
                populateFilterOptions(cachedGanttDataMain, true);
                // Sync selected filters
                selectedFiltersFullscreen = new Set(selectedFilters);
                // Update checkboxes to match
                document.querySelectorAll('#ganttFilterOptionsFullscreen input[type="checkbox"]').forEach(cb => {
                    const label = decodeURIComponent(cb.value);
                    cb.checked = selectedFiltersFullscreen.has(label);
                });
                updateFilterText(true);
                applyFilterAndRenderFullscreen();
            } else {
                onGroupByChangeFullscreen();
            }
        }

        function closeGanttFullscreen() {
            const modal = document.getElementById('ganttFullscreenModal');
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }

        async function updateGanttChartFullscreen() {
            let groupByFields = getSelectedGroupByFields(true);
            if (groupByFields.length === 0) {
                groupByFields = ['ProjectID'];
            }
            const groupBy = groupByFields.join(',');

            try {
                const data = await fetchGanttData(groupBy);

                if (data) {
                    cachedGanttDataMain = data;
                    populateFilterOptions(data, true);
                    renderGanttChartFullscreen(data);
                } else {
                    document.getElementById('ganttFullscreenBody').innerHTML =
                        '<div class="gantt-empty">No warranty data available</div>';
                }
            } catch (error) {
                console.error('Error in updateGanttChartFullscreen:', error);
                document.getElementById('ganttFullscreenBody').innerHTML =
                    '<div class="gantt-empty">Error loading warranty data</div>';
            }
        }

        function renderGanttChartFullscreen(data) {
            const container = document.getElementById('ganttFullscreenBody');

            if (!data || !data.items || data.items.length === 0) {
                container.innerHTML = '<div class="gantt-empty">No warranty data available</div>';
                return;
            }

            // Parse dates as UTC to avoid timezone issues
            const minDate = parseDateUTC(data.min_date);
            const maxDate = parseDateUTC(data.max_date);
            const today = parseDateUTC(data.today);

            if (!minDate || !maxDate) {
                container.innerHTML = '<div class="gantt-empty">Invalid date range</div>';
                return;
            }

            // Calculate total time span in days
            const totalDays = Math.round((maxDate - minDate) / (1000 * 60 * 60 * 24));

            // Generate month markers with their day counts and percentages
            const months = [];
            let currentYear = minDate.getUTCFullYear();
            let currentMonthNum = minDate.getUTCMonth();

            while (true) {
                const monthStart = new Date(Date.UTC(currentYear, currentMonthNum, 1));
                const nextMonthStart = new Date(Date.UTC(currentYear, currentMonthNum + 1, 1));

                if (monthStart >= maxDate) break;

                const effectiveStart = monthStart < minDate ? minDate : monthStart;
                const effectiveEnd = nextMonthStart > maxDate ? maxDate : nextMonthStart;
                const daysInThisMonth = Math.round((effectiveEnd - effectiveStart) / (1000 * 60 * 60 * 24));
                const widthPercent = (daysInThisMonth / totalDays) * 100;

                months.push({
                    date: monthStart,
                    label: monthStart.toLocaleDateString('en-US', { month: 'short', year: '2-digit', timeZone: 'UTC' }),
                    days: daysInThisMonth,
                    widthPercent: widthPercent
                });

                currentMonthNum++;
                if (currentMonthNum > 11) {
                    currentMonthNum = 0;
                    currentYear++;
                }
            }

            // Generate month lines HTML for rows with proper widths
            const monthLinesHtml = '<div class="gantt-month-lines">' +
                months.map(m => `<div class="gantt-month-line" style="flex: 0 0 ${m.widthPercent}%; width: ${m.widthPercent}%;"></div>`).join('') +
                '</div>';

            // Generate body-level month lines with proper widths
            const bodyMonthLinesHtml = '<div class="gantt-body-month-lines">' +
                months.map(m => `<div class="gantt-body-month-line" style="flex: 0 0 ${m.widthPercent}%; width: ${m.widthPercent}%;"></div>`).join('') +
                '</div>';

            // Group items by label for display
            const groupedItems = {};
            data.items.forEach(item => {
                if (!groupedItems[item.label]) {
                    groupedItems[item.label] = [];
                }
                groupedItems[item.label].push(item);
            });

            // Build HTML
            let html = '<div class="gantt-chart">';

            // Header with months - use proportional widths
            html += '<div class="gantt-header">';
            html += '<div class="gantt-label-header">Item</div>';
            html += '<div class="gantt-timeline-header">';
            months.forEach(month => {
                html += `<div class="gantt-month" style="flex: 0 0 ${month.widthPercent}%; width: ${month.widthPercent}%;">${month.label}</div>`;
            });
            html += '</div></div>';

            // Body with rows
            html += '<div class="gantt-body">';
            html += bodyMonthLinesHtml;

            Object.keys(groupedItems).sort().forEach(label => {
                // Apply aggregation if enabled
                const items = aggregateBarsMode ? aggregateItems(groupedItems[label]) : groupedItems[label];

                // Calculate weighted average date for this group
                const avgPercent = calculateWeightedAvgDate(items, minDate, totalDays);

                // Assign bars to rows - non-overlapping bars share the same row
                const barHeightFS = 28;
                const barGapFS = 0;
                const topPaddingFS = 0;
                const bottomPaddingFS = 0;

                // Use serial_group directly as row number (Buy and Sell from same warranty share same serial_group)
                const itemRowsFS = [];
                let maxRowFS = 0;

                items.forEach((item, idx) => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);
                    if (startDate && endDate && startDate <= endDate) {
                        const row = typeof item.serial_group === 'number' ? item.serial_group : idx;
                        itemRowsFS[idx] = row;
                        if (row > maxRowFS) maxRowFS = row;
                    } else {
                        itemRowsFS[idx] = -1;
                    }
                });

                const numRowsFS = maxRowFS + 1;
                const rowTimelineHeightFS = numRowsFS * barHeightFS;

                html += `<div class="gantt-row">`;
                html += `<div class="gantt-row-label" title="${label}">${label}</div>`;
                html += `<div class="gantt-row-timeline" style="height: ${rowTimelineHeightFS}px;">`;
                html += monthLinesHtml;

                items.forEach((item, idx) => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);
                    const dataAttrs = `data-label="${encodeURIComponent(label)}" data-start="${item.start || ''}" data-end="${item.end || ''}" data-volume="${item.volume}" data-fullscreen="true"`;

                    if (startDate && endDate && startDate <= endDate && itemRowsFS[idx] >= 0) {
                        // Calculate position and width using UTC dates
                        const startOffset = Math.round((startDate - minDate) / (1000 * 60 * 60 * 24));
                        const endOffset = Math.round((endDate - minDate) / (1000 * 60 * 60 * 24)) + 1;

                        const leftPercent = (startOffset / totalDays) * 100;
                        const widthPercent = ((endOffset - startOffset) / totalDays) * 100;

                        // Calculate top position based on assigned row
                        const topPositionFS = itemRowsFS[idx] * barHeightFS;

                        // Create tooltip text
                        const periodLabel = item.period_type === 'sell' ? 'Sell' : 'Buy';
                        const tooltipText = `${label}\n${periodLabel} Warranty\nStart: ${item.start}\nEnd: ${item.end}\nVolume: ${item.volume}\nClick to view credits`;

                        const aggregateSellStyleFS = (aggregateBarsMode && item.period_type === 'sell') ? ' padding: 0;' : '';
                        html += `<div class="gantt-bar ${item.status} ${item.period_type || 'buy'}"
                            style="left: ${leftPercent}%; width: ${widthPercent}%; top: ${topPositionFS}px;${aggregateSellStyleFS}"
                            title="${tooltipText}" ${dataAttrs} data-period-type="${item.period_type || 'buy'}"
                            onclick="showCreditsDialogFullscreen(this)">${item.volume}</div>`;
                    }
                });

                html += '</div>'; // Close timeline

                // Add weighted average line (positioned relative to row, after 200px label)
                if (avgPercent !== null && avgPercent >= 0 && avgPercent <= 100) {
                    html += `<div class="gantt-avg-line" style="left: calc(200px + (100% - 200px) * ${avgPercent / 100});" title="Weighted avg warranty date"></div>`;
                }

                html += '</div>'; // Close row
            });

            // Add today line - position relative to timeline area (after 200px label)
            // Add +1 day to align with end of bars that end today (same logic as bar endOffset)
            const todayOffset = Math.round((today - minDate) / (1000 * 60 * 60 * 24)) + 1;
            const todayPercent = (todayOffset / totalDays) * 100;
            if (todayPercent >= 0 && todayPercent <= 100) {
                html += `<div class="gantt-today-line" style="left: calc(200px + (100% - 200px) * ${todayPercent / 100})" title="Today"></div>`;
            }

            html += '</div></div>';

            container.innerHTML = html;
        }

        async function showCreditsDialogFullscreen(barElement) {
            const label = decodeURIComponent(barElement.dataset.label);
            const startDate = barElement.dataset.start;
            const endDate = barElement.dataset.end;
            const periodType = barElement.dataset.periodType || 'buy';

            // Get current group by fields from fullscreen (multi-select)
            const groupByFields = getSelectedGroupByFields(true);

            // Fetch warranty data to get matching credits
            try {
                const response = await fetch('/api/warranties/get');
                if (!response.ok) throw new Error('Failed to fetch warranties');
                const warrantyData = await response.json();

                // Filter credits that match this bar based on period type (Buy or Sell)
                const matchingCredits = warrantyData.data.filter(item => {
                    // Build composite group key from multiple fields (same as backend)
                    const keyParts = [];
                    for (const field of groupByFields) {
                        const value = item[field];
                        if (!value || String(value).trim() === '') {
                            return false; // Skip items with empty group field values
                        }
                        keyParts.push(String(value).trim());
                    }
                    const itemGroupValue = keyParts.join(' | ');

                    let itemStart, itemEnd;
                    if (periodType === 'sell') {
                        itemStart = item.Sell_Start || '';
                        itemEnd = item.Sell_End || '';
                    } else {
                        itemStart = item.Buy_Start || '';
                        itemEnd = item.Buy_End || '';
                    }

                    return itemGroupValue === label &&
                           itemStart === startDate &&
                           itemEnd === endDate;
                });

                // Update dialog title and subtitle
                document.getElementById('creditsDialogTitle').textContent = label;
                const periodLabel = periodType === 'sell' ? 'Sell' : 'Buy';
                let subtitle = '';
                if (startDate && endDate) {
                    subtitle = `${periodLabel} Warranty Period: ${startDate} to ${endDate}`;
                } else {
                    subtitle = 'No warranty dates set';
                }
                document.getElementById('creditsDialogSubtitle').textContent = subtitle;

                // Group credits by serial range
                const groupedCredits = groupSerialsByRange(matchingCredits);

                // Populate table
                const tbody = document.getElementById('creditsDialogBody');
                if (groupedCredits.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="17" style="text-align: center; color: #999;">No credits found</td></tr>';
                } else {
                    tbody.innerHTML = groupedCredits.map(group => `
                        <tr>
                            <td title="${group.serialRange}">${group.serialRange}</td>
                            <td><strong>${group.count}</strong></td>
                            <td>${group.market}</td>
                            <td>${group.registry}</td>
                            <td>${group.product}</td>
                            <td>${group.projectId}</td>
                            <td>${group.projectName}</td>
                            <td>${group.projectType}</td>
                            <td>${group.protocol}</td>
                            <td>${group.buyStart}</td>
                            <td>${group.buyEnd}</td>
                            <td>${group.buyTradeId}</td>
                            <td>${group.buyClient}</td>
                            <td>${group.sellStart}</td>
                            <td>${group.sellEnd}</td>
                            <td>${group.sellTradeId}</td>
                            <td>${group.sellClient}</td>
                        </tr>
                    `).join('');
                }

                // Update count
                document.getElementById('creditsDialogCount').textContent = matchingCredits.length;

                // Show dialog
                document.getElementById('creditsDialogOverlay').classList.add('active');

            } catch (error) {
                console.error('Error fetching credits:', error);
                alert('Failed to load credits data');
            }
        }

        // Close fullscreen on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeGanttFullscreen();
                closeCreditsDialog();
            }
        });

        // Credits Dialog Functions
        function groupSerialsByRange(credits) {
            // Group credits by common attributes (excluding Serial)
            const groups = {};

            credits.forEach(credit => {
                const key = `${credit.Market || ''}|${credit.Registry || ''}|${credit.Product || ''}|${credit.ProjectID || ''}|${credit.ProjectName || ''}|${credit.ProjectType || ''}|${credit.Protocol || ''}|${credit.Buy_Start || ''}|${credit.Buy_End || ''}|${credit.Buy_TradeID || ''}|${credit.Buy_Client || ''}|${credit.Sell_Start || ''}|${credit.Sell_End || ''}|${credit.Sell_TradeID || ''}|${credit.Sell_Client || ''}`;

                if (!groups[key]) {
                    groups[key] = {
                        serials: [],
                        market: credit.Market || '-',
                        registry: credit.Registry || '-',
                        product: credit.Product || '-',
                        projectId: credit.ProjectID || '-',
                        projectName: credit.ProjectName || '-',
                        projectType: credit.ProjectType || '-',
                        protocol: credit.Protocol || '-',
                        buyStart: credit.Buy_Start || '-',
                        buyEnd: credit.Buy_End || '-',
                        buyTradeId: credit.Buy_TradeID || '-',
                        buyClient: credit.Buy_Client || '-',
                        sellStart: credit.Sell_Start || '-',
                        sellEnd: credit.Sell_End || '-',
                        sellTradeId: credit.Sell_TradeID || '-',
                        sellClient: credit.Sell_Client || '-'
                    };
                }
                groups[key].serials.push(credit.Serial);
            });

            // Convert to array and create serial ranges
            return Object.values(groups).map(group => {
                // Sort serials
                const sortedSerials = group.serials.sort();
                const ranges = [];
                let rangeStart = null;
                let rangeEnd = null;
                let prevSerial = null;

                // Try to detect consecutive serials
                sortedSerials.forEach((serial, idx) => {
                    if (rangeStart === null) {
                        rangeStart = serial;
                        rangeEnd = serial;
                    } else {
                        // Check if this serial is "consecutive" to the previous one
                        // Simple heuristic: if they share a common prefix and differ only in suffix numbers
                        const isConsecutive = areConsecutiveSerials(prevSerial, serial);

                        if (isConsecutive) {
                            rangeEnd = serial;
                        } else {
                            // Save current range and start new one
                            if (rangeStart === rangeEnd) {
                                ranges.push(rangeStart);
                            } else {
                                ranges.push(`${rangeStart} - ${rangeEnd}`);
                            }
                            rangeStart = serial;
                            rangeEnd = serial;
                        }
                    }
                    prevSerial = serial;
                });

                // Don't forget the last range
                if (rangeStart !== null) {
                    if (rangeStart === rangeEnd) {
                        ranges.push(rangeStart);
                    } else {
                        ranges.push(`${rangeStart} - ${rangeEnd}`);
                    }
                }

                return {
                    serialRange: ranges.length > 3 ? `${ranges[0]}, ... (${ranges.length} ranges)` : ranges.join(', '),
                    count: group.serials.length,
                    market: group.market,
                    registry: group.registry,
                    product: group.product,
                    projectId: group.projectId,
                    projectName: group.projectName,
                    projectType: group.projectType,
                    protocol: group.protocol,
                    buyStart: group.buyStart,
                    buyEnd: group.buyEnd,
                    buyTradeId: group.buyTradeId,
                    buyClient: group.buyClient,
                    sellStart: group.sellStart,
                    sellEnd: group.sellEnd,
                    sellTradeId: group.sellTradeId,
                    sellClient: group.sellClient
                };
            });
        }

        function areConsecutiveSerials(serial1, serial2) {
            if (!serial1 || !serial2) return false;

            // Extract numeric suffixes
            const match1 = serial1.match(/^(.+?)(\d+)$/);
            const match2 = serial2.match(/^(.+?)(\d+)$/);

            if (match1 && match2 && match1[1] === match2[1]) {
                const num1 = parseInt(match1[2]);
                const num2 = parseInt(match2[2]);
                return num2 === num1 + 1;
            }
            return false;
        }

        async function showCreditsDialog(barElement) {
            const label = decodeURIComponent(barElement.dataset.label);
            const startDate = barElement.dataset.start;
            const endDate = barElement.dataset.end;
            const volume = barElement.dataset.volume;
            const periodType = barElement.dataset.periodType || 'buy';

            // Get current group by fields (multi-select)
            const groupByFields = getSelectedGroupByFields(false);

            // Fetch warranty data to get matching credits
            try {
                const response = await fetch('/api/warranties/get');
                if (!response.ok) throw new Error('Failed to fetch warranties');
                const warrantyData = await response.json();

                // Filter credits that match this bar based on period type (Buy or Sell)
                const matchingCredits = warrantyData.data.filter(item => {
                    // Build composite group key from multiple fields (same as backend)
                    const keyParts = [];
                    for (const field of groupByFields) {
                        const value = item[field];
                        if (!value || String(value).trim() === '') {
                            return false; // Skip items with empty group field values
                        }
                        keyParts.push(String(value).trim());
                    }
                    const itemGroupValue = keyParts.join(' | ');

                    let itemStart, itemEnd;
                    if (periodType === 'sell') {
                        itemStart = item.Sell_Start || '';
                        itemEnd = item.Sell_End || '';
                    } else {
                        itemStart = item.Buy_Start || '';
                        itemEnd = item.Buy_End || '';
                    }

                    return itemGroupValue === label &&
                           itemStart === startDate &&
                           itemEnd === endDate;
                });

                // Update dialog title and subtitle
                document.getElementById('creditsDialogTitle').textContent = label;
                const periodLabel = periodType === 'sell' ? 'Sell' : 'Buy';
                let subtitle = '';
                if (startDate && endDate) {
                    subtitle = `${periodLabel} Warranty Period: ${startDate} to ${endDate}`;
                } else {
                    subtitle = 'No warranty dates set';
                }
                document.getElementById('creditsDialogSubtitle').textContent = subtitle;

                // Group credits by serial range
                const groupedCredits = groupSerialsByRange(matchingCredits);

                // Populate table
                const tbody = document.getElementById('creditsDialogBody');
                if (groupedCredits.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="17" style="text-align: center; color: #999;">No credits found</td></tr>';
                } else {
                    tbody.innerHTML = groupedCredits.map(group => `
                        <tr>
                            <td title="${group.serialRange}">${group.serialRange}</td>
                            <td><strong>${group.count}</strong></td>
                            <td>${group.market}</td>
                            <td>${group.registry}</td>
                            <td>${group.product}</td>
                            <td>${group.projectId}</td>
                            <td>${group.projectName}</td>
                            <td>${group.projectType}</td>
                            <td>${group.protocol}</td>
                            <td>${group.buyStart}</td>
                            <td>${group.buyEnd}</td>
                            <td>${group.buyTradeId}</td>
                            <td>${group.buyClient}</td>
                            <td>${group.sellStart}</td>
                            <td>${group.sellEnd}</td>
                            <td>${group.sellTradeId}</td>
                            <td>${group.sellClient}</td>
                        </tr>
                    `).join('');
                }

                // Update count
                document.getElementById('creditsDialogCount').textContent = matchingCredits.length;

                // Show dialog
                document.getElementById('creditsDialogOverlay').classList.add('active');
                document.body.style.overflow = 'hidden';

            } catch (error) {
                console.error('Error fetching credits:', error);
                alert('Failed to load credits data');
            }
        }

        function closeCreditsDialog(event) {
            // If called from overlay click, only close if clicking the overlay itself
            if (event && event.target !== event.currentTarget) return;

            document.getElementById('creditsDialogOverlay').classList.remove('active');
            if (!document.getElementById('ganttFullscreenModal').classList.contains('active')) {
                document.body.style.overflow = '';
            }
        }
    </script>
</body>
</html>
