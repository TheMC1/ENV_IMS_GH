<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Carbon IMS</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container dashboard-container">
        <div class="dashboard-box">
            <header class="home-header">
                <h1>Dashboard</h1>
                <div class="header-actions">
                    <a href="{{ url_for('auth.home') }}" class="btn-secondary">Home</a>
                    <a href="{{ url_for('auth.logout') }}" class="btn-logout">Logout</a>
                </div>
            </header>

            {% with messages = get_flashed_messages(with_categories=true) %}
                {% if messages %}
                    {% for category, message in messages %}
                        <div class="alert alert-{{ category }}">
                            {{ message }}
                        </div>
                    {% endfor %}
                {% endif %}
            {% endwith %}

            <div class="dashboard-quartiles">
                <!-- Cell 1: Pie Chart -->
                <div class="quartile" id="quartile-1">
                    <div class="quartile-header">
                        <h3>Inventory by Category</h3>
                        <div class="chart-controls">
                            <label>Group by:</label>
                            <div class="multi-select-wrapper" id="pieGroupByWrapper">
                                <div class="multi-select-display" onclick="toggleFilterDropdown('pieGroupByDropdown')">
                                    <span id="pieGroupByText">Registry</span>
                                    <span class="multi-select-arrow">&#9662;</span>
                                </div>
                                <div class="multi-select-dropdown" id="pieGroupByDropdown">
                                    <div class="groupby-order-list" id="pieGroupByOrderList">
                                    </div>
                                    <div class="multi-select-actions">
                                        <button type="button" onclick="clearAllPieGroupBy()">Clear All</button>
                                    </div>
                                    <div class="multi-select-options" id="pieGroupByOptions">
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="pie_groupby_Registry" value="Registry" checked onchange="onPieGroupByChange(event)">
                                            <label for="pie_groupby_Registry">Registry</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="pie_groupby_Market" value="Market" onchange="onPieGroupByChange(event)">
                                            <label for="pie_groupby_Market">Market</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="pie_groupby_Product" value="Product" onchange="onPieGroupByChange(event)">
                                            <label for="pie_groupby_Product">Product</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="pie_groupby_ProjectType" value="ProjectType" onchange="onPieGroupByChange(event)">
                                            <label for="pie_groupby_ProjectType">Project Type</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="pie_groupby_Protocol" value="Protocol" onchange="onPieGroupByChange(event)">
                                            <label for="pie_groupby_Protocol">Protocol</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="pie_groupby_Vintage" value="Vintage" onchange="onPieGroupByChange(event)">
                                            <label for="pie_groupby_Vintage">Vintage</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="pie_groupby_IsCustody" value="IsCustody" onchange="onPieGroupByChange(event)">
                                            <label for="pie_groupby_IsCustody">Custody Status</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="pieChart"></canvas>
                    </div>
                    <div class="chart-stats" id="chartStats">
                        <span class="stat-total">Total: <strong id="totalCount">0</strong> items</span>
                    </div>
                </div>

                <!-- Cell 2: Inventory Summary -->
                <div class="quartile" id="quartile-2">
                    <div class="quartile-header">
                        <h3>Inventory Summary</h3>
                        <div class="chart-controls">
                            <label>Group by:</label>
                            <div class="multi-select-wrapper" id="summaryGroupByWrapper">
                                <div class="multi-select-display" onclick="toggleFilterDropdown('summaryGroupByDropdown')">
                                    <span id="summaryGroupByText">Registry</span>
                                    <span class="multi-select-arrow">&#9662;</span>
                                </div>
                                <div class="multi-select-dropdown" id="summaryGroupByDropdown">
                                    <div class="groupby-order-list" id="summaryGroupByOrderList">
                                    </div>
                                    <div class="multi-select-actions">
                                        <button type="button" onclick="clearAllSummaryGroupBy()">Clear All</button>
                                    </div>
                                    <div class="multi-select-options" id="summaryGroupByOptions">
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="summary_groupby_Registry" value="Registry" checked onchange="onSummaryGroupByChange(event)">
                                            <label for="summary_groupby_Registry">Registry</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="summary_groupby_Market" value="Market" onchange="onSummaryGroupByChange(event)">
                                            <label for="summary_groupby_Market">Market</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="summary_groupby_Product" value="Product" onchange="onSummaryGroupByChange(event)">
                                            <label for="summary_groupby_Product">Product</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="summary_groupby_ProjectType" value="ProjectType" onchange="onSummaryGroupByChange(event)">
                                            <label for="summary_groupby_ProjectType">Project Type</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="summary_groupby_Protocol" value="Protocol" onchange="onSummaryGroupByChange(event)">
                                            <label for="summary_groupby_Protocol">Protocol</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="summary_groupby_Vintage" value="Vintage" onchange="onSummaryGroupByChange(event)">
                                            <label for="summary_groupby_Vintage">Vintage</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="summary_groupby_IsCustody" value="IsCustody" onchange="onSummaryGroupByChange(event)">
                                            <label for="summary_groupby_IsCustody">Custody Status</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="quartile-content placeholder-content">
                        <div class="summary-stats" id="summaryStats">
                            <!-- Will be populated by JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- Cell 3: Warranty Alerts -->
                <div class="quartile" id="quartile-3">
                    <div class="quartile-header">
                        <h3>Warranty Alerts</h3>
                    </div>
                    <div class="quartile-content">
                        <div class="alerts-container" id="warrantyAlertsContainer">
                            <div class="alerts-loading">Loading alerts...</div>
                        </div>
                    </div>
                </div>

                <!-- Cell 4: Warranty Timeline Gantt Chart (spans 3 columns) -->
                <div class="quartile span-3" id="quartile-4">
                    <div class="quartile-header">
                        <h3>Warranty Timeline</h3>
                        <div class="gantt-controls">
                            <label>Group by:</label>
                            <div class="multi-select-wrapper" id="ganttGroupByWrapper">
                                <div class="multi-select-display" onclick="toggleFilterDropdown('ganttGroupByDropdown')">
                                    <span id="ganttGroupByText">Project ID</span>
                                    <span class="multi-select-arrow">&#9662;</span>
                                </div>
                                <div class="multi-select-dropdown" id="ganttGroupByDropdown">
                                    <div class="groupby-order-list" id="groupByOrderList">
                                        <!-- Ordered selected items will be displayed here -->
                                    </div>
                                    <div class="multi-select-actions">
                                        <button type="button" onclick="clearAllGroupBy()">Clear All</button>
                                    </div>
                                    <div class="multi-select-options" id="ganttGroupByOptions">
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_ProjectID" value="ProjectID" checked onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_ProjectID">Project ID</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Registry" value="Registry" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Registry">Registry</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Market" value="Market" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Market">Market</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Product" value="Product" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Product">Product</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_ProjectType" value="ProjectType" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_ProjectType">Project Type</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Protocol" value="Protocol" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Protocol">Protocol</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Vintage" value="Vintage" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Vintage">Vintage</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Buy_Client" value="Buy_Client" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Buy_Client">Buy Client</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Buy_TradeID" value="Buy_TradeID" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Buy_TradeID">Buy Trade ID</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Sell_Client" value="Sell_Client" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Sell_Client">Sell Client</label>
                                        </div>
                                        <div class="multi-select-option">
                                            <input type="checkbox" id="groupby_Sell_TradeID" value="Sell_TradeID" onchange="onGroupByCheckboxChange(event)">
                                            <label for="groupby_Sell_TradeID">Sell Trade ID</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="gantt-filter-container">
                                <label for="ganttFilter">Filter:</label>
                                <div class="multi-select-wrapper" id="ganttFilterWrapper">
                                    <div class="multi-select-display" onclick="toggleFilterDropdown('ganttFilterDropdown')">
                                        <span id="ganttFilterText">All Items</span>
                                        <span class="multi-select-arrow">&#9662;</span>
                                    </div>
                                    <div class="multi-select-dropdown" id="ganttFilterDropdown">
                                        <div class="multi-select-actions">
                                            <button type="button" onclick="selectAllFilters()">Select All</button>
                                            <button type="button" onclick="clearAllFilters()">Clear All</button>
                                        </div>
                                        <div class="multi-select-options" id="ganttFilterOptions">
                                            <!-- Options populated dynamically -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="gantt-aggregate-toggle">
                                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; white-space: nowrap;">
                                    <input type="checkbox" id="aggregateBarsToggle" onchange="toggleAggregateBars()">
                                    <span>Aggregate Bars</span>
                                </label>
                            </div>
                            <button class="btn-fullscreen" onclick="openGanttFullscreen()" title="View fullscreen">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                                </svg>
                                Fullscreen
                            </button>
                        </div>
                    </div>
                    <div class="gantt-container" id="ganttContainer">
                        <div class="gantt-empty">Loading warranty data...</div>
                    </div>
                    <div class="gantt-legend">
                        <div class="legend-item">
                            <span class="legend-color active"></span>
                            <span>Active (>90 days)</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color expiring-90"></span>
                            <span>Expiring 90 days</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color expiring-30"></span>
                            <span>Expiring 30 days</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color expired"></span>
                            <span>Expired</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color buy-indicator"></span>
                            <span>Buy Warranty</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color sell-indicator"></span>
                            <span>Sell Warranty</span>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Credits Data Dialog -->
    <div class="credits-dialog-overlay" id="creditsDialogOverlay" onclick="closeCreditsDialog(event)">
        <div class="credits-dialog" onclick="event.stopPropagation()">
            <div class="credits-dialog-header">
                <div>
                    <h3 id="creditsDialogTitle">Credits Details</h3>
                    <div class="dialog-subtitle" id="creditsDialogSubtitle"></div>
                </div>
                <button class="credits-dialog-close" onclick="closeCreditsDialog()">&times;</button>
            </div>
            <div class="credits-dialog-body">
                <table class="credits-table">
                    <thead id="creditsDialogHead">
                        <tr>
                            <th>Serial Range</th>
                            <th>Count</th>
                            <th>Market</th>
                            <th>Registry</th>
                            <th>Product</th>
                            <th>Project ID</th>
                            <th>Project Name</th>
                            <th>Project Type</th>
                            <th>Protocol</th>
                            <th>Vintage</th>
                            <th>Buy Start</th>
                            <th>Buy End</th>
                            <th>Buy Trade ID</th>
                            <th>Buy Client</th>
                            <th>Sell Start</th>
                            <th>Sell End</th>
                            <th>Sell Trade ID</th>
                            <th>Sell Client</th>
                        </tr>
                    </thead>
                    <tbody id="creditsDialogBody">
                    </tbody>
                </table>
            </div>
            <div class="credits-dialog-footer">
                <span class="credits-count">Total: <strong id="creditsDialogCount">0</strong> credits</span>
                <button class="btn-secondary" onclick="closeCreditsDialog()">Close</button>
            </div>
        </div>
    </div>

    <!-- Fullscreen Modal for Gantt Chart -->
    <div class="gantt-fullscreen-modal" id="ganttFullscreenModal">
        <div class="gantt-fullscreen-header">
            <h2>Warranty Timeline</h2>
            <div class="gantt-fullscreen-controls">
                <label>Group by:</label>
                <div class="multi-select-wrapper" id="ganttGroupByWrapperFullscreen">
                    <div class="multi-select-display" onclick="toggleFilterDropdown('ganttGroupByDropdownFullscreen')">
                        <span id="ganttGroupByTextFullscreen">Project ID</span>
                        <span class="multi-select-arrow">&#9662;</span>
                    </div>
                    <div class="multi-select-dropdown" id="ganttGroupByDropdownFullscreen">
                        <div class="groupby-order-list" id="groupByOrderListFullscreen">
                            <!-- Ordered selected items will be displayed here -->
                        </div>
                        <div class="multi-select-actions">
                            <button type="button" onclick="clearAllGroupByFullscreen()">Clear All</button>
                        </div>
                        <div class="multi-select-options" id="ganttGroupByOptionsFullscreen">
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_ProjectID" value="ProjectID" checked onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_ProjectID">Project ID</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Registry" value="Registry" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Registry">Registry</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Market" value="Market" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Market">Market</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Product" value="Product" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Product">Product</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_ProjectType" value="ProjectType" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_ProjectType">Project Type</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Protocol" value="Protocol" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Protocol">Protocol</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Vintage" value="Vintage" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Vintage">Vintage</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Buy_Client" value="Buy_Client" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Buy_Client">Buy Client</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Buy_TradeID" value="Buy_TradeID" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Buy_TradeID">Buy Trade ID</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Sell_Client" value="Sell_Client" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Sell_Client">Sell Client</label>
                            </div>
                            <div class="multi-select-option">
                                <input type="checkbox" id="groupby_fs_Sell_TradeID" value="Sell_TradeID" onchange="onGroupByCheckboxChangeFullscreen(event)">
                                <label for="groupby_fs_Sell_TradeID">Sell Trade ID</label>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="gantt-filter-container">
                    <label for="ganttFilterFullscreen">Filter:</label>
                    <div class="multi-select-wrapper" id="ganttFilterWrapperFullscreen">
                        <div class="multi-select-display" onclick="toggleFilterDropdown('ganttFilterDropdownFullscreen')">
                            <span id="ganttFilterTextFullscreen">All Items</span>
                            <span class="multi-select-arrow">&#9662;</span>
                        </div>
                        <div class="multi-select-dropdown" id="ganttFilterDropdownFullscreen">
                            <div class="multi-select-actions">
                                <button type="button" onclick="selectAllFiltersFullscreen()">Select All</button>
                                <button type="button" onclick="clearAllFiltersFullscreen()">Clear All</button>
                            </div>
                            <div class="multi-select-options" id="ganttFilterOptionsFullscreen">
                                <!-- Options populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="gantt-aggregate-toggle">
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; white-space: nowrap;">
                        <input type="checkbox" id="aggregateBarsToggleFullscreen" onchange="toggleAggregateBarsFullscreen()">
                        <span>Aggregate Bars</span>
                    </label>
                </div>
                <button class="btn-close-fullscreen" onclick="closeGanttFullscreen()">Close</button>
            </div>
        </div>
        <div class="gantt-fullscreen-body" id="ganttFullscreenBody">
            <div class="gantt-empty">Loading warranty data...</div>
        </div>
        <div class="gantt-fullscreen-legend">
            <div class="legend-item">
                <span class="legend-color active"></span>
                <span>Active (>90 days)</span>
            </div>
            <div class="legend-item">
                <span class="legend-color expiring-90"></span>
                <span>Expiring 90 days</span>
            </div>
            <div class="legend-item">
                <span class="legend-color expiring-30"></span>
                <span>Expiring 30 days</span>
            </div>
            <div class="legend-item">
                <span class="legend-color expired"></span>
                <span>Expired</span>
            </div>
            <div class="legend-item">
                <span class="legend-color buy-indicator"></span>
                <span>Buy Warranty</span>
            </div>
            <div class="legend-item">
                <span class="legend-color sell-indicator"></span>
                <span>Sell Warranty</span>
            </div>
        </div>
    </div>

    <script>
        let pieChart = null;
        const chartColors = [
            '#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe',
            '#00f2fe', '#43e97b', '#38f9d7', '#fa709a', '#fee140',
            '#30cfd0', '#c779d0', '#feac5e', '#a8edea', '#fed6e3'
        ];

        // State for multi-select group by fields
        let pieGroupByOrder = ['Registry'];
        let summaryGroupByOrder = ['Registry'];

        // Pie Chart Group By Functions
        function onPieGroupByChange(event) {
            const value = event.target.value;
            const checked = event.target.checked;

            if (checked) {
                if (!pieGroupByOrder.includes(value)) {
                    pieGroupByOrder.push(value);
                }
            } else {
                pieGroupByOrder = pieGroupByOrder.filter(v => v !== value);
            }

            renderPieGroupByOrder();
            updatePieGroupByText();
            updateChart();
            saveDashboardSettings();
        }

        function renderPieGroupByOrder() {
            const orderList = document.getElementById('pieGroupByOrderList');
            if (pieGroupByOrder.length === 0) {
                orderList.innerHTML = '';
                return;
            }

            orderList.innerHTML = pieGroupByOrder.map((field, index) => `
                <div class="groupby-order-item" draggable="true" data-field="${field}" data-type="pie" data-index="${index}">
                    <span class="drag-handle">&#9776;</span>
                    <span class="groupby-order-num">${index + 1}</span>
                    <span class="groupby-order-name">${getFieldDisplayName(field)}</span>
                    <button type="button" class="groupby-order-btn remove" onclick="removePieGroupBy('${field}')" title="Remove">&times;</button>
                </div>
            `).join('');

            setupGenericDragAndDrop(orderList, 'pie');
        }

        function removePieGroupBy(field) {
            pieGroupByOrder = pieGroupByOrder.filter(v => v !== field);
            document.getElementById('pie_groupby_' + field).checked = false;
            renderPieGroupByOrder();
            updatePieGroupByText();
            updateChart();
            saveDashboardSettings();
        }

        function clearAllPieGroupBy() {
            pieGroupByOrder = [];
            document.querySelectorAll('#pieGroupByOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            renderPieGroupByOrder();
            updatePieGroupByText();
            updateChart();
            saveDashboardSettings();
        }

        function updatePieGroupByText() {
            const textEl = document.getElementById('pieGroupByText');
            if (pieGroupByOrder.length === 0) {
                textEl.textContent = 'Select fields...';
            } else if (pieGroupByOrder.length === 1) {
                textEl.textContent = getFieldDisplayName(pieGroupByOrder[0]);
            } else {
                textEl.textContent = pieGroupByOrder.map(f => getFieldDisplayName(f)).join(', ');
            }
        }

        // Summary Group By Functions
        function onSummaryGroupByChange(event) {
            const value = event.target.value;
            const checked = event.target.checked;

            if (checked) {
                if (!summaryGroupByOrder.includes(value)) {
                    summaryGroupByOrder.push(value);
                }
            } else {
                summaryGroupByOrder = summaryGroupByOrder.filter(v => v !== value);
            }

            renderSummaryGroupByOrder();
            updateSummaryGroupByText();
            updateSummaryView();
            saveDashboardSettings();
        }

        function renderSummaryGroupByOrder() {
            const orderList = document.getElementById('summaryGroupByOrderList');
            if (summaryGroupByOrder.length === 0) {
                orderList.innerHTML = '';
                return;
            }

            orderList.innerHTML = summaryGroupByOrder.map((field, index) => `
                <div class="groupby-order-item" draggable="true" data-field="${field}" data-type="summary" data-index="${index}">
                    <span class="drag-handle">&#9776;</span>
                    <span class="groupby-order-num">${index + 1}</span>
                    <span class="groupby-order-name">${getFieldDisplayName(field)}</span>
                    <button type="button" class="groupby-order-btn remove" onclick="removeSummaryGroupBy('${field}')" title="Remove">&times;</button>
                </div>
            `).join('');

            setupGenericDragAndDrop(orderList, 'summary');
        }

        function removeSummaryGroupBy(field) {
            summaryGroupByOrder = summaryGroupByOrder.filter(v => v !== field);
            document.getElementById('summary_groupby_' + field).checked = false;
            renderSummaryGroupByOrder();
            updateSummaryGroupByText();
            updateSummaryView();
            saveDashboardSettings();
        }

        function clearAllSummaryGroupBy() {
            summaryGroupByOrder = [];
            document.querySelectorAll('#summaryGroupByOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            renderSummaryGroupByOrder();
            updateSummaryGroupByText();
            updateSummaryView();
            saveDashboardSettings();
        }

        function updateSummaryGroupByText() {
            const textEl = document.getElementById('summaryGroupByText');
            if (summaryGroupByOrder.length === 0) {
                textEl.textContent = 'Select fields...';
            } else if (summaryGroupByOrder.length === 1) {
                textEl.textContent = getFieldDisplayName(summaryGroupByOrder[0]);
            } else {
                textEl.textContent = summaryGroupByOrder.map(f => getFieldDisplayName(f)).join(', ');
            }
        }

        // Generic drag and drop for pie and summary group-by lists
        function setupGenericDragAndDrop(listEl, type) {
            const items = listEl.querySelectorAll('.groupby-order-item');
            let draggedItem = null;
            let draggedIndex = null;

            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedItem = item;
                    draggedIndex = parseInt(item.dataset.index);
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    draggedItem = null;
                    draggedIndex = null;
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    if (item !== draggedItem) {
                        item.classList.add('drag-over');
                    }
                });

                item.addEventListener('dragleave', () => {
                    item.classList.remove('drag-over');
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');

                    const dropIndex = parseInt(item.dataset.index);
                    if (draggedIndex !== null && draggedIndex !== dropIndex) {
                        if (type === 'pie') {
                            const [movedField] = pieGroupByOrder.splice(draggedIndex, 1);
                            pieGroupByOrder.splice(dropIndex, 0, movedField);
                            renderPieGroupByOrder();
                            updatePieGroupByText();
                            updateChart();
                        } else if (type === 'summary') {
                            const [movedField] = summaryGroupByOrder.splice(draggedIndex, 1);
                            summaryGroupByOrder.splice(dropIndex, 0, movedField);
                            renderSummaryGroupByOrder();
                            updateSummaryGroupByText();
                            updateSummaryView();
                        }
                        saveDashboardSettings();
                    }
                });
            });
        }

        async function fetchChartData(groupBy = 'Registry') {
            try {
                const response = await fetch(`/api/dashboard/stats?group_by=${groupBy}`);
                if (!response.ok) throw new Error('Failed to fetch data');
                return await response.json();
            } catch (error) {
                console.error('Error fetching chart data:', error);
                return null;
            }
        }

        function createPieChart(data) {
            const ctx = document.getElementById('pieChart').getContext('2d');

            if (pieChart) {
                pieChart.destroy();
            }

            // Check if we have hierarchical data for multi-level donut
            if (data.hierarchical && data.levels && data.levels.length > 1) {
                createMultiLevelDonut(ctx, data);
            } else {
                // Restore default chartStats for single-level chart
                const chartStats = document.getElementById('chartStats');
                if (chartStats) {
                    chartStats.innerHTML = `<span class="stat-total">Total: <strong id="totalCount">${data.total || 0}</strong> items</span>`;
                }
                // Single level pie chart
                pieChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: data.labels,
                        datasets: [{
                            data: data.values,
                            backgroundColor: chartColors.slice(0, data.labels.length),
                            borderColor: '#fff',
                            borderWidth: 2,
                            hoverOffset: 10
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '40%',
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    padding: 15,
                                    usePointStyle: true,
                                    pointStyle: 'circle',
                                    font: {
                                        size: 11,
                                        family: 'Roboto'
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = ((context.parsed / total) * 100).toFixed(1);
                                        return `${context.label}: ${context.parsed} (${percentage}%)`;
                                    }
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const label = pieChart.data.labels[index];
                                const value = pieChart.data.datasets[0].data[index];
                                showChartDetail(label, value);
                            }
                        }
                    }
                });
            }
        }

        function createMultiLevelDonut(ctx, data) {
            const levels = data.levels;
            const numLevels = levels.length;

            // Generate color maps for consistency across levels
            const level0Colors = {};
            levels[0].labels.forEach((label, idx) => {
                level0Colors[label] = chartColors[idx % chartColors.length];
            });

            // Build datasets for each level (inner to outer)
            const datasets = [];
            const cutoutStart = 25;
            const ringWidth = Math.min(30, (75 - cutoutStart) / numLevels);

            for (let levelIdx = 0; levelIdx < numLevels; levelIdx++) {
                const level = levels[levelIdx];
                const colors = [];

                // Assign colors based on parent hierarchy
                level.labels.forEach((label, idx) => {
                    if (levelIdx === 0) {
                        colors.push(level0Colors[label]);
                    } else {
                        // Find root parent and use its color with variation
                        let parentLabel = label;
                        for (let i = levelIdx; i > 0; i--) {
                            parentLabel = levels[i].parent_map[parentLabel] || parentLabel;
                        }
                        const baseColor = level0Colors[parentLabel] || chartColors[idx % chartColors.length];
                        // Add slight variation for child levels
                        colors.push(adjustColorBrightness(baseColor, levelIdx * 15));
                    }
                });

                const cutout = cutoutStart + (levelIdx * ringWidth);
                const radius = cutoutStart + ((levelIdx + 1) * ringWidth);

                datasets.push({
                    data: level.values,
                    backgroundColor: colors,
                    borderColor: '#fff',
                    borderWidth: 1,
                    hoverOffset: 5,
                    // Store level info for tooltip
                    levelField: level.field,
                    levelLabels: level.labels
                });
            }

            // Create chart with multiple datasets
            pieChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: levels[numLevels - 1].labels, // Use outermost labels for legend
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: cutoutStart + '%',
                    plugins: {
                        legend: {
                            display: false // Hide default legend for multi-level
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const datasetIndex = context[0].datasetIndex;
                                    const field = datasets[datasetIndex].levelField;
                                    return getFieldDisplayName(field);
                                },
                                label: function(context) {
                                    const datasetIndex = context.datasetIndex;
                                    const index = context.dataIndex;
                                    const label = datasets[datasetIndex].levelLabels[index];
                                    const value = context.parsed;
                                    const total = data.total;
                                    const percentage = ((value / total) * 100).toFixed(1);

                                    // Show only the last part of the label for cleaner display
                                    const displayLabel = label.includes(' | ') ? label.split(' | ').pop() : label;
                                    return `${displayLabel}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const datasetIndex = elements[0].datasetIndex;
                            const index = elements[0].index;
                            const label = datasets[datasetIndex].levelLabels[index];
                            const value = datasets[datasetIndex].data[index];
                            showChartDetail(label, value);
                        }
                    }
                }
            });

            // Create custom legend for multi-level chart
            createMultiLevelLegend(levels, level0Colors);
        }

        function adjustColorBrightness(hex, percent) {
            // Convert hex to RGB, adjust brightness, convert back
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);

            r = Math.min(255, Math.floor(r + (255 - r) * percent / 100));
            g = Math.min(255, Math.floor(g + (255 - g) * percent / 100));
            b = Math.min(255, Math.floor(b + (255 - b) * percent / 100));

            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function createMultiLevelLegend(levels, colorMap) {
            // Create a simple legend showing the first level categories
            const legendContainer = document.getElementById('chartStats');
            if (!legendContainer) return;

            let html = '<div class="multi-level-legend">';
            levels[0].labels.forEach((label, idx) => {
                const color = colorMap[label];
                const value = levels[0].values[idx];
                html += `<span class="legend-item" style="--color: ${color}">
                    <span class="legend-color" style="background: ${color}"></span>
                    ${label} (${value})
                </span>`;
            });
            html += '</div>';
            html += `<span class="stat-total">Total: <strong id="totalCount">${levels[0].values.reduce((a, b) => a + b, 0)}</strong> items</span>`;
            legendContainer.innerHTML = html;
        }

        function showChartDetail(label, value) {
            const groupByLabel = pieGroupByOrder.map(f => getFieldDisplayName(f)).join(' | ');
            alert(`${groupByLabel}: ${label}\nCount: ${value} items`);
        }

        function updateSummaryStats(data, groupByFields) {
            const summaryContainer = document.getElementById('summaryStats');
            if (!data || !data.labels) {
                summaryContainer.innerHTML = '<p class="placeholder-text">No data available</p>';
                return;
            }

            let html = '';
            const groupByLabel = groupByFields ? groupByFields.map(f => getFieldDisplayName(f)).join(' | ') : 'Category';

            // Create summary cards for top categories
            const sortedData = data.labels.map((label, i) => ({
                label: label,
                value: data.values[i]
            })).sort((a, b) => b.value - a.value);

            const topItems = sortedData.slice(0, 5);

            html += `<div class="summary-header">Top ${groupByLabel} Categories</div>`;
            html += '<div class="summary-list">';

            topItems.forEach((item, index) => {
                const percentage = ((item.value / data.total) * 100).toFixed(1);
                html += `
                    <div class="summary-item">
                        <span class="summary-rank" style="background: ${chartColors[index]}">${index + 1}</span>
                        <span class="summary-label">${item.label}</span>
                        <span class="summary-value">${item.value} <small>(${percentage}%)</small></span>
                    </div>
                `;
            });

            html += '</div>';
            summaryContainer.innerHTML = html;
        }

        async function updateSummaryView() {
            if (summaryGroupByOrder.length === 0) {
                document.getElementById('summaryStats').innerHTML = '<p class="placeholder-text">Select at least one field to group by</p>';
                return;
            }
            const groupBy = summaryGroupByOrder.join(',');
            const data = await fetchChartData(groupBy);

            if (data && data.labels) {
                updateSummaryStats(data, summaryGroupByOrder);
            }
        }

        async function updateChart() {
            if (pieGroupByOrder.length === 0) {
                if (pieChart) pieChart.destroy();
                pieChart = null;
                document.getElementById('totalCount').textContent = '0';
                return;
            }
            const groupBy = pieGroupByOrder.join(',');
            const data = await fetchChartData(groupBy);

            if (data && data.labels) {
                createPieChart(data);
                // Only update totalCount if not hierarchical (hierarchical updates it in legend)
                if (!data.hierarchical) {
                    document.getElementById('totalCount').textContent = data.total;
                }
            }
        }

        // Dashboard Settings Persistence
        async function loadDashboardSettings() {
            try {
                const response = await fetch('/api/settings/dashboard');
                if (!response.ok) return {};
                const data = await response.json();
                return data.settings || {};
            } catch (error) {
                console.error('Error loading dashboard settings:', error);
                return {};
            }
        }

        async function saveDashboardSettings() {
            try {
                const settings = collectCurrentSettings();
                await fetch('/api/settings/dashboard', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
            } catch (error) {
                console.error('Error saving dashboard settings:', error);
            }
        }

        function collectCurrentSettings() {
            const settings = {};

            // Pie chart group by - save the ordered array
            settings.pieGroupBy = [...pieGroupByOrder];

            // Summary group by - save the ordered array
            settings.summaryGroupBy = [...summaryGroupByOrder];

            // Gantt chart group by - save the ordered array
            settings.ganttGroupBy = [...groupByOrder];

            // Gantt chart filters
            const filterCheckboxes = document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]');
            settings.ganttFilters = [];
            filterCheckboxes.forEach(cb => {
                if (cb.checked) {
                    settings.ganttFilters.push(decodeURIComponent(cb.value));
                }
            });

            // Aggregate bars toggle
            settings.aggregateBars = aggregateBarsMode;

            return settings;
        }

        function applySettings(settings) {
            if (!settings || Object.keys(settings).length === 0) {
                // No settings - render initial order lists
                renderPieGroupByOrder();
                renderSummaryGroupByOrder();
                renderGroupByOrderList(false);
                return;
            }

            // Apply pie chart group by - restore the ordered array
            if (settings.pieGroupBy && Array.isArray(settings.pieGroupBy) && settings.pieGroupBy.length > 0) {
                pieGroupByOrder = [...settings.pieGroupBy];
                document.querySelectorAll('#pieGroupByOptions input[type="checkbox"]').forEach(cb => {
                    cb.checked = pieGroupByOrder.includes(cb.value);
                });
                renderPieGroupByOrder();
                updatePieGroupByText();
            } else {
                renderPieGroupByOrder();
            }

            // Apply summary group by - restore the ordered array
            if (settings.summaryGroupBy && Array.isArray(settings.summaryGroupBy) && settings.summaryGroupBy.length > 0) {
                summaryGroupByOrder = [...settings.summaryGroupBy];
                document.querySelectorAll('#summaryGroupByOptions input[type="checkbox"]').forEach(cb => {
                    cb.checked = summaryGroupByOrder.includes(cb.value);
                });
                renderSummaryGroupByOrder();
                updateSummaryGroupByText();
            } else {
                renderSummaryGroupByOrder();
            }

            // Apply gantt group by - restore the ordered array
            if (settings.ganttGroupBy && Array.isArray(settings.ganttGroupBy) && settings.ganttGroupBy.length > 0) {
                groupByOrder = [...settings.ganttGroupBy];
                document.querySelectorAll('#ganttGroupByOptions input[type="checkbox"]').forEach(cb => {
                    cb.checked = groupByOrder.includes(cb.value);
                });
                renderGroupByOrderList(false);
                updateGroupByText();
            } else {
                // No saved settings - render initial order list
                renderGroupByOrderList(false);
            }

            // Apply aggregate bars toggle
            if (settings.aggregateBars !== undefined) {
                aggregateBarsMode = settings.aggregateBars;
                document.getElementById('aggregateBarsToggle').checked = aggregateBarsMode;
                document.getElementById('aggregateBarsToggleFullscreen').checked = aggregateBarsMode;
            }
        }

        function applyFiltersAfterLoad(settings) {
            // Apply gantt filters after data is loaded
            // Only apply filters that exist in the current data options
            if (settings.ganttFilters && Array.isArray(settings.ganttFilters) && settings.ganttFilters.length > 0) {
                const availableFilters = new Set();
                document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                    availableFilters.add(decodeURIComponent(cb.value));
                });

                // Check if any saved filters match current options
                const matchingFilters = settings.ganttFilters.filter(f => availableFilters.has(f));

                if (matchingFilters.length > 0) {
                    selectedFilters.clear();
                    document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                        const label = decodeURIComponent(cb.value);
                        if (matchingFilters.includes(label)) {
                            cb.checked = true;
                            selectedFilters.add(label);
                        } else {
                            cb.checked = false;
                        }
                    });
                    updateFilterText(false);
                    applyFilterAndRender();
                }
                // If no matching filters, keep all selected (default behavior from populateFilterOptions)
            }
        }

        // Store loaded settings for use after data loads
        let loadedSettings = {};

        // Initialize chart on page load
        document.addEventListener('DOMContentLoaded', async function() {
            // Load saved settings first
            loadedSettings = await loadDashboardSettings();

            // Apply settings to UI elements
            applySettings(loadedSettings);

            // Then load charts
            updateChart();
            updateSummaryView();
            await updateGanttChart();

            // Apply filters after chart data is loaded
            if (loadedSettings.ganttFilters) {
                applyFiltersAfterLoad(loadedSettings);
            }

            // Load warranty alerts
            await loadWarrantyAlerts();
        });

        // Warranty Alerts Functions
        async function loadWarrantyAlerts() {
            const container = document.getElementById('warrantyAlertsContainer');
            try {
                const response = await fetch('/api/dashboard/warranty-alerts');
                if (!response.ok) throw new Error('Failed to fetch alerts');
                const data = await response.json();

                renderWarrantyAlerts(data);
            } catch (error) {
                console.error('Error loading warranty alerts:', error);
                container.innerHTML = '<div class="alerts-empty">Failed to load alerts</div>';
            }
        }

        function renderWarrantyAlerts(data) {
            const container = document.getElementById('warrantyAlertsContainer');
            const { alerts, counts } = data;

            const totalAlerts = (alerts.upcoming?.length || 0) +
                               (alerts.buy_expiring?.length || 0) +
                               (alerts.sell_expiring?.length || 0) +
                               (alerts.expired?.length || 0);

            if (totalAlerts === 0) {
                container.innerHTML = '<div class="alerts-empty">No warranty alerts at this time</div>';
                return;
            }

            let html = '';

            // Summary badges
            html += '<div class="alerts-summary">';
            if (counts.upcoming > 0) {
                html += `<span class="alert-badge upcoming">&#128198; ${counts.upcoming} upcoming</span>`;
            }
            if (counts.buy_expiring > 0) {
                html += `<span class="alert-badge expiring">&#9888; ${counts.buy_expiring} buy expiring</span>`;
            }
            if (counts.sell_expiring > 0) {
                html += `<span class="alert-badge expiring">&#9888; ${counts.sell_expiring} sell expiring</span>`;
            }
            if (counts.expired > 0) {
                html += `<span class="alert-badge expired">&#10060; ${counts.expired} expired</span>`;
            }
            html += '</div>';

            // Alert items - Show expired first, then expiring (buy then sell), then upcoming
            alerts.expired?.forEach(alert => {
                html += renderAlertItem(alert, 'expired');
            });

            alerts.buy_expiring?.forEach(alert => {
                html += renderAlertItem(alert, 'buy_expiring');
            });

            alerts.sell_expiring?.forEach(alert => {
                html += renderAlertItem(alert, 'sell_expiring');
            });

            alerts.upcoming?.forEach(alert => {
                html += renderAlertItem(alert, 'upcoming');
            });

            container.innerHTML = html;
        }

        function renderAlertItem(alert, type) {
            let icon, cssClass, periodLabel;

            if (type === 'upcoming') {
                icon = '&#128198;';
                cssClass = 'upcoming';
                periodLabel = '';
            } else if (type === 'buy_expiring') {
                icon = '&#9888;';
                cssClass = 'expiring';
                periodLabel = 'Buy ';
            } else if (type === 'sell_expiring') {
                icon = '&#9888;';
                cssClass = 'expiring';
                periodLabel = 'Sell ';
            } else {
                icon = '&#10060;';
                cssClass = 'expired';
                periodLabel = alert.period ? `${alert.period} ` : '';
            }

            const title = alert.project_name || alert.project_id || 'Unknown Project';
            const displayTitle = title.length > 25 ? title.substring(0, 25) + '...' : title;

            let dateLabel = '';
            if (type === 'upcoming') {
                dateLabel = alert.days === 1 ? 'Starts tomorrow' : `Starts in ${alert.days} days`;
            } else if (type === 'buy_expiring' || type === 'sell_expiring') {
                dateLabel = alert.days === 0 ? `${periodLabel}expires today` :
                           (alert.days === 1 ? `${periodLabel}expires tomorrow` :
                           `${periodLabel}expires in ${alert.days} days`);
            } else {
                dateLabel = alert.days === -1 ? `${periodLabel}expired yesterday` :
                           `${periodLabel}expired ${Math.abs(alert.days)} days ago`;
            }

            return `
                <div class="alert-item ${cssClass}" onclick="window.location.href='{{ url_for('warranties.warranties') }}'">
                    <span class="alert-icon">${icon}</span>
                    <div class="alert-content">
                        <div class="alert-title" title="${title}">${displayTitle}</div>
                        <div class="alert-details">${alert.count} credit${alert.count !== 1 ? 's' : ''} - ${alert.project_id}</div>
                    </div>
                    <span class="alert-date">${dateLabel}</span>
                </div>
            `;
        }

        // Gantt Chart Functions
        async function fetchGanttData(groupBy = 'ProjectID') {
            try {
                const response = await fetch(`/api/dashboard/warranty-gantt?group_by=${groupBy}`);
                if (!response.ok) throw new Error('Failed to fetch data');
                return await response.json();
            } catch (error) {
                console.error('Error fetching Gantt data:', error);
                return null;
            }
        }

        function parseDate(dateStr) {
            if (!dateStr) return null;
            // Try YYYY-MM-DD format
            let date = new Date(dateStr);
            if (!isNaN(date.getTime())) return date;
            // Try MM/DD/YYYY format
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                date = new Date(parts[2], parts[0] - 1, parts[1]);
                if (!isNaN(date.getTime())) return date;
            }
            return null;
        }

        // Store warranty data for dialog
        let cachedWarrantyData = null;
        let cachedGanttDataMain = null;
        let selectedFilters = new Set();
        let selectedFiltersFullscreen = new Set();
        let aggregateBarsMode = false;

        // Ordered arrays for group by fields (maintains user-specified order)
        let groupByOrder = ['ProjectID'];  // Default order
        let groupByOrderFullscreen = ['ProjectID'];

        // Group By multi-select functions
        function getSelectedGroupByFields(isFullscreen = false) {
            // Return the ordered array instead of reading from DOM
            return isFullscreen ? [...groupByOrderFullscreen] : [...groupByOrder];
        }

        function setGroupByOrder(order, isFullscreen = false) {
            if (isFullscreen) {
                groupByOrderFullscreen = [...order];
            } else {
                groupByOrder = [...order];
            }
        }

        function updateGroupByText() {
            const selected = getSelectedGroupByFields(false);
            const textEl = document.getElementById('ganttGroupByText');
            if (selected.length === 0) {
                textEl.textContent = 'Select fields...';
            } else if (selected.length <= 2) {
                textEl.textContent = selected.map(f => getFieldDisplayName(f)).join(' > ');
            } else {
                textEl.textContent = `${selected.length} levels`;
            }
        }

        function updateGroupByTextFullscreen() {
            const selected = getSelectedGroupByFields(true);
            const textEl = document.getElementById('ganttGroupByTextFullscreen');
            if (selected.length === 0) {
                textEl.textContent = 'Select fields...';
            } else if (selected.length <= 2) {
                textEl.textContent = selected.map(f => getFieldDisplayName(f)).join(' > ');
            } else {
                textEl.textContent = `${selected.length} levels`;
            }
        }

        function getFieldDisplayName(field) {
            const names = {
                'ProjectID': 'Project ID',
                'Registry': 'Registry',
                'Market': 'Market',
                'Product': 'Product',
                'ProjectType': 'Project Type',
                'Protocol': 'Protocol',
                'Vintage': 'Vintage',
                'Buy_Client': 'Buy Client',
                'Sell_Client': 'Sell Client',
                'Buy_TradeID': 'Buy Trade ID',
                'Sell_TradeID': 'Sell Trade ID'
            };
            return names[field] || field;
        }

        // Render the ordered list of selected fields
        function renderGroupByOrderList(isFullscreen = false) {
            const order = isFullscreen ? groupByOrderFullscreen : groupByOrder;
            const listId = isFullscreen ? 'groupByOrderListFullscreen' : 'groupByOrderList';
            const listEl = document.getElementById(listId);

            if (order.length === 0) {
                listEl.innerHTML = '';
                return;
            }

            listEl.innerHTML = order.map((field, idx) => `
                <div class="groupby-order-item" draggable="true" data-field="${field}" data-index="${idx}">
                    <span class="drag-handle">&#9776;</span>
                    <span class="groupby-order-num">${idx + 1}</span>
                    <span class="groupby-order-name">${getFieldDisplayName(field)}</span>
                    <div class="groupby-order-controls">
                        <button class="groupby-order-btn" onclick="moveGroupByField(${idx}, -1, ${isFullscreen})" ${idx === 0 ? 'disabled' : ''} title="Move up">&#9650;</button>
                        <button class="groupby-order-btn" onclick="moveGroupByField(${idx}, 1, ${isFullscreen})" ${idx === order.length - 1 ? 'disabled' : ''} title="Move down">&#9660;</button>
                        <button class="groupby-order-btn remove" onclick="removeGroupByField('${field}', ${isFullscreen})" title="Remove">&times;</button>
                    </div>
                </div>
            `).join('');

            // Add drag and drop event listeners
            setupDragAndDrop(listEl, isFullscreen);
        }

        function setupDragAndDrop(listEl, isFullscreen) {
            const items = listEl.querySelectorAll('.groupby-order-item');
            let draggedItem = null;
            let draggedIndex = null;

            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedItem = item;
                    draggedIndex = parseInt(item.dataset.index);
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    items.forEach(i => i.classList.remove('drag-over'));
                    draggedItem = null;
                    draggedIndex = null;
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    if (item !== draggedItem) {
                        item.classList.add('drag-over');
                    }
                });

                item.addEventListener('dragleave', () => {
                    item.classList.remove('drag-over');
                });

                item.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');

                    const dropIndex = parseInt(item.dataset.index);
                    if (draggedIndex !== null && draggedIndex !== dropIndex) {
                        const order = isFullscreen ? groupByOrderFullscreen : groupByOrder;
                        const [movedField] = order.splice(draggedIndex, 1);
                        order.splice(dropIndex, 0, movedField);

                        renderGroupByOrderList(isFullscreen);
                        if (isFullscreen) {
                            updateGroupByTextFullscreen();
                            await onGroupByChangeFullscreen();
                            syncFromFullscreen();
                        } else {
                            updateGroupByText();
                            await onGroupByChange();
                        }
                        saveDashboardSettings();
                    }
                });
            });
        }

        async function moveGroupByField(index, direction, isFullscreen = false) {
            const order = isFullscreen ? groupByOrderFullscreen : groupByOrder;
            const newIndex = index + direction;

            if (newIndex < 0 || newIndex >= order.length) return;

            // Swap elements
            [order[index], order[newIndex]] = [order[newIndex], order[index]];

            renderGroupByOrderList(isFullscreen);
            if (isFullscreen) {
                updateGroupByTextFullscreen();
                await onGroupByChangeFullscreen();
                syncFromFullscreen();
            } else {
                updateGroupByText();
                await onGroupByChange();
            }
            saveDashboardSettings();
        }

        async function removeGroupByField(field, isFullscreen = false) {
            const order = isFullscreen ? groupByOrderFullscreen : groupByOrder;
            const idx = order.indexOf(field);
            if (idx > -1) {
                order.splice(idx, 1);
            }

            // Uncheck the checkbox
            const checkboxId = isFullscreen ? `groupby_fs_${field}` : `groupby_${field}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) checkbox.checked = false;

            renderGroupByOrderList(isFullscreen);
            if (isFullscreen) {
                updateGroupByTextFullscreen();
                await onGroupByChangeFullscreen();
                syncFromFullscreen();
            } else {
                updateGroupByText();
                await onGroupByChange();
            }
            saveDashboardSettings();
        }

        function syncFromFullscreen() {
            // Sync order from fullscreen to main
            groupByOrder = [...groupByOrderFullscreen];

            // Sync checkboxes
            document.querySelectorAll('#ganttGroupByOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = groupByOrder.includes(cb.value);
            });

            renderGroupByOrderList(false);
            updateGroupByText();
        }

        async function clearAllGroupBy() {
            groupByOrder = [];
            document.querySelectorAll('#ganttGroupByOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            renderGroupByOrderList(false);
            updateGroupByText();
            await onGroupByChange();
            saveDashboardSettings();
        }

        async function clearAllGroupByFullscreen() {
            groupByOrderFullscreen = [];
            document.querySelectorAll('#ganttGroupByOptionsFullscreen input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            renderGroupByOrderList(true);
            updateGroupByTextFullscreen();
            await onGroupByChangeFullscreen();
            syncFromFullscreen();
            saveDashboardSettings();
        }

        async function onGroupByCheckboxChange(event) {
            const checkbox = event ? event.target : null;
            if (checkbox) {
                const field = checkbox.value;
                if (checkbox.checked) {
                    // Add to end of order if not already present
                    if (!groupByOrder.includes(field)) {
                        groupByOrder.push(field);
                    }
                } else {
                    // Remove from order
                    const idx = groupByOrder.indexOf(field);
                    if (idx > -1) {
                        groupByOrder.splice(idx, 1);
                    }
                }
            }

            renderGroupByOrderList(false);
            updateGroupByText();
            await onGroupByChange();
            saveDashboardSettings();
        }

        async function onGroupByCheckboxChangeFullscreen(event) {
            const checkbox = event ? event.target : null;
            if (checkbox) {
                const field = checkbox.value;
                if (checkbox.checked) {
                    // Add to end of order if not already present
                    if (!groupByOrderFullscreen.includes(field)) {
                        groupByOrderFullscreen.push(field);
                    }
                } else {
                    // Remove from order
                    const idx = groupByOrderFullscreen.indexOf(field);
                    if (idx > -1) {
                        groupByOrderFullscreen.splice(idx, 1);
                    }
                }
            }

            renderGroupByOrderList(true);
            updateGroupByTextFullscreen();
            await onGroupByChangeFullscreen();
            syncFromFullscreen();
            saveDashboardSettings();
        }

        // Filter dropdown functions
        function toggleFilterDropdown(dropdownId) {
            const dropdown = document.getElementById(dropdownId);
            const isActive = dropdown.classList.contains('active');

            // Close all dropdowns first
            document.querySelectorAll('.multi-select-dropdown').forEach(d => d.classList.remove('active'));

            if (!isActive) {
                dropdown.classList.add('active');
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.multi-select-wrapper')) {
                document.querySelectorAll('.multi-select-dropdown').forEach(d => d.classList.remove('active'));
            }
        });

        function populateFilterOptions(data, isFullscreen = false) {
            const optionsContainer = document.getElementById(isFullscreen ? 'ganttFilterOptionsFullscreen' : 'ganttFilterOptions');
            const filterTextEl = document.getElementById(isFullscreen ? 'ganttFilterTextFullscreen' : 'ganttFilterText');
            const filterSet = isFullscreen ? selectedFiltersFullscreen : selectedFilters;

            if (!data || !data.items || data.items.length === 0) {
                optionsContainer.innerHTML = '<div style="padding: 10px; color: #999;">No items available</div>';
                return;
            }

            // Get unique labels
            const uniqueLabels = [...new Set(data.items.map(item => item.label))].sort();

            // Clear and reset filters if group changed
            filterSet.clear();
            uniqueLabels.forEach(label => filterSet.add(label));

            // Build options HTML
            optionsContainer.innerHTML = uniqueLabels.map(label => `
                <div class="multi-select-option">
                    <input type="checkbox" id="${isFullscreen ? 'fs_' : ''}filter_${encodeURIComponent(label)}"
                           value="${encodeURIComponent(label)}" checked
                           onchange="${isFullscreen ? 'onFilterChangeFullscreen' : 'onFilterChange'}(this)">
                    <label for="${isFullscreen ? 'fs_' : ''}filter_${encodeURIComponent(label)}">${label}</label>
                </div>
            `).join('');

            updateFilterText(isFullscreen);
        }

        function onFilterChange(checkbox) {
            const label = decodeURIComponent(checkbox.value);
            if (checkbox.checked) {
                selectedFilters.add(label);
            } else {
                selectedFilters.delete(label);
            }
            updateFilterText(false);
            applyFilterAndRender();
            saveDashboardSettings();
        }

        function onFilterChangeFullscreen(checkbox) {
            const label = decodeURIComponent(checkbox.value);
            if (checkbox.checked) {
                selectedFiltersFullscreen.add(label);
            } else {
                selectedFiltersFullscreen.delete(label);
            }
            updateFilterText(true);
            applyFilterAndRenderFullscreen();
            // Sync back to main and save
            selectedFilters = new Set(selectedFiltersFullscreen);
            document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                const cbLabel = decodeURIComponent(cb.value);
                cb.checked = selectedFilters.has(cbLabel);
            });
            updateFilterText(false);
            saveDashboardSettings();
        }

        function updateFilterText(isFullscreen) {
            const filterTextEl = document.getElementById(isFullscreen ? 'ganttFilterTextFullscreen' : 'ganttFilterText');
            const filterSet = isFullscreen ? selectedFiltersFullscreen : selectedFilters;
            const optionsContainer = document.getElementById(isFullscreen ? 'ganttFilterOptionsFullscreen' : 'ganttFilterOptions');
            const totalOptions = optionsContainer.querySelectorAll('input[type="checkbox"]').length;

            if (filterSet.size === 0) {
                filterTextEl.textContent = 'None Selected';
            } else if (filterSet.size === totalOptions) {
                filterTextEl.textContent = 'All Items';
            } else if (filterSet.size <= 2) {
                filterTextEl.textContent = [...filterSet].join(', ');
            } else {
                filterTextEl.textContent = `${filterSet.size} selected`;
            }
        }

        function selectAllFilters() {
            document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
                selectedFilters.add(decodeURIComponent(cb.value));
            });
            updateFilterText(false);
            applyFilterAndRender();
            saveDashboardSettings();
        }

        function clearAllFilters() {
            document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            selectedFilters.clear();
            updateFilterText(false);
            applyFilterAndRender();
            saveDashboardSettings();
        }

        function selectAllFiltersFullscreen() {
            document.querySelectorAll('#ganttFilterOptionsFullscreen input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
                selectedFiltersFullscreen.add(decodeURIComponent(cb.value));
            });
            updateFilterText(true);
            applyFilterAndRenderFullscreen();
            // Sync back to main
            selectedFilters = new Set(selectedFiltersFullscreen);
            document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            saveDashboardSettings();
        }

        function clearAllFiltersFullscreen() {
            document.querySelectorAll('#ganttFilterOptionsFullscreen input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            selectedFiltersFullscreen.clear();
            updateFilterText(true);
            applyFilterAndRenderFullscreen();
            // Sync back to main
            selectedFilters.clear();
            document.querySelectorAll('#ganttFilterOptions input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            saveDashboardSettings();
        }

        function applyFilterAndRender() {
            if (!cachedGanttDataMain) return;

            const filteredData = {
                ...cachedGanttDataMain,
                items: cachedGanttDataMain.items.filter(item => selectedFilters.has(item.label))
            };
            renderGanttChart(filteredData);
        }

        function applyFilterAndRenderFullscreen() {
            if (!cachedGanttDataMain) return;

            const filteredData = {
                ...cachedGanttDataMain,
                items: cachedGanttDataMain.items.filter(item => selectedFiltersFullscreen.has(item.label))
            };
            renderGanttChartFullscreen(filteredData);
        }

        function toggleAggregateBars() {
            aggregateBarsMode = document.getElementById('aggregateBarsToggle').checked;
            // Sync fullscreen toggle
            document.getElementById('aggregateBarsToggleFullscreen').checked = aggregateBarsMode;
            applyFilterAndRender();
            saveDashboardSettings();
        }

        function toggleAggregateBarsFullscreen() {
            aggregateBarsMode = document.getElementById('aggregateBarsToggleFullscreen').checked;
            // Sync main toggle
            document.getElementById('aggregateBarsToggle').checked = aggregateBarsMode;
            applyFilterAndRenderFullscreen();
            saveDashboardSettings();
        }

        function aggregateItems(items) {
            // Group items by period_type (buy/sell)
            const buyItems = items.filter(item => item.period_type === 'buy' || !item.period_type);
            const sellItems = items.filter(item => item.period_type === 'sell');

            const aggregated = [];
            const label = items.length > 0 ? items[0].label : '';

            let buyStart = null, buyEnd = null;
            let sellStart = null, sellEnd = null;

            // Aggregate buy items
            if (buyItems.length > 0) {
                let earliestStart = null;
                let latestEnd = null;
                let totalVolume = 0;

                buyItems.forEach(item => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);

                    if (startDate && (!earliestStart || startDate < earliestStart)) {
                        earliestStart = startDate;
                    }
                    if (endDate && (!latestEnd || endDate > latestEnd)) {
                        latestEnd = endDate;
                    }
                    totalVolume += parseInt(item.volume) || 0;
                });

                if (earliestStart && latestEnd) {
                    buyStart = earliestStart;
                    buyEnd = latestEnd;

                    // Determine status based on latestEnd
                    const today = new Date();
                    const daysUntilExpiry = Math.ceil((latestEnd - today) / (1000 * 60 * 60 * 24));
                    let status = 'active';
                    if (daysUntilExpiry <= 30) status = 'expiring-30';
                    else if (daysUntilExpiry <= 60) status = 'expiring-60';
                    else if (daysUntilExpiry <= 90) status = 'expiring-90';

                    aggregated.push({
                        label: label,
                        start: earliestStart.toISOString().split('T')[0],
                        end: latestEnd.toISOString().split('T')[0],
                        volume: totalVolume,
                        status: status,
                        period_type: 'buy',
                        serial_group: 0
                    });
                }
            }

            // Aggregate sell items
            if (sellItems.length > 0) {
                let earliestStart = null;
                let latestEnd = null;
                let totalVolume = 0;

                sellItems.forEach(item => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);

                    if (startDate && (!earliestStart || startDate < earliestStart)) {
                        earliestStart = startDate;
                    }
                    if (endDate && (!latestEnd || endDate > latestEnd)) {
                        latestEnd = endDate;
                    }
                    totalVolume += parseInt(item.volume) || 0;
                });

                if (earliestStart && latestEnd) {
                    sellStart = earliestStart;
                    sellEnd = latestEnd;

                    // Determine status based on latestEnd
                    const today = new Date();
                    const daysUntilExpiry = Math.ceil((latestEnd - today) / (1000 * 60 * 60 * 24));
                    let status = 'active';
                    if (daysUntilExpiry <= 30) status = 'expiring-30';
                    else if (daysUntilExpiry <= 60) status = 'expiring-60';
                    else if (daysUntilExpiry <= 90) status = 'expiring-90';

                    // Check if buy and sell bars overlap
                    // Overlap occurs if: buyStart <= sellEnd AND sellStart <= buyEnd
                    let sellSerialGroup = 0;
                    if (buyStart && buyEnd && sellStart && sellEnd) {
                        const barsOverlap = (buyStart <= sellEnd) && (sellStart <= buyEnd);
                        if (barsOverlap) {
                            sellSerialGroup = 1; // Put sell on separate row if overlapping
                        }
                    }

                    aggregated.push({
                        label: label,
                        start: earliestStart.toISOString().split('T')[0],
                        end: latestEnd.toISOString().split('T')[0],
                        volume: totalVolume,
                        status: status,
                        period_type: 'sell',
                        serial_group: sellSerialGroup
                    });
                }
            }

            return aggregated;
        }

        async function onGroupByChange() {
            let groupByFields = getSelectedGroupByFields(false);
            if (groupByFields.length === 0) {
                document.getElementById('ganttContainer').innerHTML =
                    '<div class="gantt-empty">Please select at least one grouping field</div>';
                return;
            }
            const groupBy = groupByFields.join(',');

            try {
                const data = await fetchGanttData(groupBy);

                if (data) {
                    cachedGanttDataMain = data;
                    populateFilterOptions(data, false);
                    renderGanttChart(data);
                } else {
                    document.getElementById('ganttContainer').innerHTML =
                        '<div class="gantt-empty">No warranty data available</div>';
                }
            } catch (error) {
                console.error('Error in onGroupByChange:', error);
                document.getElementById('ganttContainer').innerHTML =
                    '<div class="gantt-empty">Error loading warranty data</div>';
            }
        }

        async function onGroupByChangeFullscreen() {
            let groupByFields = getSelectedGroupByFields(true);
            if (groupByFields.length === 0) {
                document.getElementById('ganttFullscreenBody').innerHTML =
                    '<div class="gantt-empty">Please select at least one grouping field</div>';
                return;
            }
            const groupBy = groupByFields.join(',');

            try {
                const data = await fetchGanttData(groupBy);

                if (data) {
                    cachedGanttDataMain = data;
                    populateFilterOptions(data, true);
                    renderGanttChartFullscreen(data);
                } else {
                    document.getElementById('ganttFullscreenBody').innerHTML =
                        '<div class="gantt-empty">No warranty data available</div>';
                }
            } catch (error) {
                console.error('Error in onGroupByChangeFullscreen:', error);
                document.getElementById('ganttFullscreenBody').innerHTML =
                    '<div class="gantt-empty">Error loading warranty data</div>';
            }
        }

        function calculateWeightedAvgDate(items, minDate, totalDays) {
            let totalWeight = 0;
            let weightedSum = 0;

            items.forEach(item => {
                const startDate = parseDateUTC(item.start);
                const endDate = parseDateUTC(item.end);

                if (startDate && endDate) {
                    // Calculate midpoint of warranty period
                    const midpoint = new Date((startDate.getTime() + endDate.getTime()) / 2);
                    const dayOffset = Math.round((midpoint - minDate) / (1000 * 60 * 60 * 24));

                    weightedSum += dayOffset * item.volume;
                    totalWeight += item.volume;
                }
            });

            if (totalWeight === 0) return null;

            const avgDayOffset = weightedSum / totalWeight;
            return (avgDayOffset / totalDays) * 100;
        }

        // Helper to parse date string to UTC date (avoiding timezone issues)
        function parseDateUTC(dateStr) {
            if (!dateStr) return null;
            // Handle YYYY-MM-DD format (with 1 or 2 digit month/day)
            const match = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})/);
            if (match) {
                return new Date(Date.UTC(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3])));
            }
            // Handle MM/DD/YYYY format
            const match2 = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
            if (match2) {
                return new Date(Date.UTC(parseInt(match2[3]), parseInt(match2[1]) - 1, parseInt(match2[2])));
            }
            return null;
        }

        function renderGanttChart(data) {
            const container = document.getElementById('ganttContainer');
            cachedWarrantyData = data;

            if (!data || !data.items || data.items.length === 0) {
                container.innerHTML = '<div class="gantt-empty">No warranty data available</div>';
                return;
            }

            // Parse dates as UTC to avoid timezone issues
            const minDate = parseDateUTC(data.min_date);
            const maxDate = parseDateUTC(data.max_date);
            const today = parseDateUTC(data.today);

            if (!minDate || !maxDate) {
                container.innerHTML = '<div class="gantt-empty">Invalid date range</div>';
                return;
            }

            // Calculate total time span in days
            const totalDays = Math.round((maxDate - minDate) / (1000 * 60 * 60 * 24));

            // Generate month markers with their day counts and percentages
            const months = [];
            let currentYear = minDate.getUTCFullYear();
            let currentMonthNum = minDate.getUTCMonth();

            while (true) {
                const monthStart = new Date(Date.UTC(currentYear, currentMonthNum, 1));
                const nextMonthStart = new Date(Date.UTC(currentYear, currentMonthNum + 1, 1));

                if (monthStart >= maxDate) break;

                const effectiveStart = monthStart < minDate ? minDate : monthStart;
                const effectiveEnd = nextMonthStart > maxDate ? maxDate : nextMonthStart;
                const daysInThisMonth = Math.round((effectiveEnd - effectiveStart) / (1000 * 60 * 60 * 24));
                const widthPercent = (daysInThisMonth / totalDays) * 100;

                months.push({
                    date: monthStart,
                    label: monthStart.toLocaleDateString('en-US', { month: 'short', year: '2-digit', timeZone: 'UTC' }),
                    days: daysInThisMonth,
                    widthPercent: widthPercent
                });

                currentMonthNum++;
                if (currentMonthNum > 11) {
                    currentMonthNum = 0;
                    currentYear++;
                }
            }

            // Generate month lines HTML for rows with proper widths
            const monthLinesHtml = '<div class="gantt-month-lines">' +
                months.map(m => `<div class="gantt-month-line" style="flex: 0 0 ${m.widthPercent}%; width: ${m.widthPercent}%;"></div>`).join('') +
                '</div>';

            // Generate body-level month lines with proper widths
            const bodyMonthLinesHtml = '<div class="gantt-body-month-lines">' +
                months.map(m => `<div class="gantt-body-month-line" style="flex: 0 0 ${m.widthPercent}%; width: ${m.widthPercent}%;"></div>`).join('') +
                '</div>';

            // Group items by label for display
            const groupedItems = {};
            data.items.forEach(item => {
                if (!groupedItems[item.label]) {
                    groupedItems[item.label] = [];
                }
                groupedItems[item.label].push(item);
            });

            // Build HTML
            let html = '<div class="gantt-chart">';

            // Header with months - use proportional widths
            html += '<div class="gantt-header">';
            html += '<div class="gantt-label-header">Item</div>';
            html += '<div class="gantt-timeline-header">';
            months.forEach(month => {
                html += `<div class="gantt-month" style="flex: 0 0 ${month.widthPercent}%; width: ${month.widthPercent}%;">${month.label}</div>`;
            });
            html += '</div></div>';

            // Body with rows
            html += '<div class="gantt-body">';
            html += bodyMonthLinesHtml;

            Object.keys(groupedItems).sort().forEach(label => {
                // Apply aggregation if enabled
                const items = aggregateBarsMode ? aggregateItems(groupedItems[label]) : groupedItems[label];

                // Calculate weighted average date for this group
                const avgPercent = calculateWeightedAvgDate(items, minDate, totalDays);

                // Assign bars to rows - non-overlapping bars share the same row
                const barHeight = 20;
                const barGap = 0;
                const topPadding = 0;
                const bottomPadding = 0;

                // Use serial_group directly as row number (Buy and Sell from same warranty share same serial_group)
                const itemRows = [];
                let maxRow = 0;

                items.forEach((item, idx) => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);
                    if (startDate && endDate && startDate <= endDate) {
                        // Use serial_group directly as row number - same as fullscreen version
                        const row = typeof item.serial_group === 'number' ? item.serial_group : idx;
                        itemRows[idx] = row;
                        if (row > maxRow) maxRow = row;
                    } else {
                        itemRows[idx] = -1;
                    }
                });

                const numRows = maxRow + 1;
                const rowTimelineHeight = numRows * barHeight;

                html += `<div class="gantt-row">`;
                html += `<div class="gantt-row-label" title="${label}">${label}</div>`;
                html += `<div class="gantt-row-timeline" style="height: ${rowTimelineHeight}px; position: relative;">`;
                html += monthLinesHtml;

                items.forEach((item, idx) => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);
                    const dataAttrs = `data-label="${encodeURIComponent(label)}" data-start="${item.start || ''}" data-end="${item.end || ''}" data-volume="${item.volume}"`;

                    if (startDate && endDate && startDate <= endDate && itemRows[idx] >= 0) {
                        // Calculate position and width using UTC dates
                        const startOffset = Math.round((startDate - minDate) / (1000 * 60 * 60 * 24));
                        const endOffset = Math.round((endDate - minDate) / (1000 * 60 * 60 * 24)) + 1;

                        const leftPercent = (startOffset / totalDays) * 100;
                        const widthPercent = ((endOffset - startOffset) / totalDays) * 100;

                        // Calculate top position based on assigned row
                        const topPosition = itemRows[idx] * barHeight;

                        // Create tooltip text
                        const periodLabel = item.period_type === 'sell' ? 'Sell' : 'Buy';
                        const tooltipText = `${label}\n${periodLabel} Warranty\nStart: ${item.start}\nEnd: ${item.end}\nVolume: ${item.volume}\nClick to view credits`;

                        const aggregateSellStyle = (aggregateBarsMode && item.period_type === 'sell') ? ' padding: 0;' : '';
                        html += `<div class="gantt-bar ${item.status} ${item.period_type || 'buy'}"
                            style="left: ${leftPercent}%; width: ${widthPercent}%; top: ${topPosition}px;${aggregateSellStyle}"
                            title="${tooltipText}" ${dataAttrs} data-period-type="${item.period_type || 'buy'}"
                            onclick="showCreditsDialog(this)">${item.volume}</div>`;
                    }
                });

                html += '</div>'; // Close timeline

                // Add weighted average line (positioned relative to row, after 150px label)
                if (avgPercent !== null && avgPercent >= 0 && avgPercent <= 100) {
                    html += `<div class="gantt-avg-line" style="left: calc(150px + (100% - 150px) * ${avgPercent / 100});" title="Weighted avg warranty date"></div>`;
                }

                html += '</div>'; // Close row
            });

            // Add today line - position relative to timeline area (after 150px label)
            // Add +1 day to align with end of bars that end today (same logic as bar endOffset)
            if (today) {
                const todayOffset = Math.round((today - minDate) / (1000 * 60 * 60 * 24)) + 1;
                const todayPercent = (todayOffset / totalDays) * 100;
                if (todayPercent >= 0 && todayPercent <= 100) {
                    html += `<div class="gantt-today-line" style="left: calc(150px + (100% - 150px) * ${todayPercent / 100})" title="Today"></div>`;
                }
            }

            html += '</div></div>';

            container.innerHTML = html;
        }

        async function updateGanttChart() {
            let groupByFields = getSelectedGroupByFields(false);
            // Default to ProjectID if nothing selected
            if (groupByFields.length === 0) {
                groupByFields = ['ProjectID'];
            }
            const groupBy = groupByFields.join(',');

            try {
                const data = await fetchGanttData(groupBy);

                if (data) {
                    cachedGanttDataMain = data;
                    populateFilterOptions(data, false);
                    renderGanttChart(data);
                } else {
                    document.getElementById('ganttContainer').innerHTML =
                        '<div class="gantt-empty">No warranty data available</div>';
                }
            } catch (error) {
                console.error('Error in updateGanttChart:', error);
                document.getElementById('ganttContainer').innerHTML =
                    '<div class="gantt-empty">Error loading warranty data</div>';
            }
        }

        // Fullscreen Gantt Chart Functions
        let cachedGanttData = null;

        function openGanttFullscreen() {
            const modal = document.getElementById('ganttFullscreenModal');
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';

            // Sync the group by order and selections from main view
            groupByOrderFullscreen = [...groupByOrder];
            const mainGroupByFields = getSelectedGroupByFields(false);
            document.querySelectorAll('#ganttGroupByOptionsFullscreen input[type="checkbox"]').forEach(cb => {
                cb.checked = mainGroupByFields.includes(cb.value);
            });
            renderGroupByOrderList(true);
            updateGroupByTextFullscreen();

            // Sync filters from main view
            if (cachedGanttDataMain) {
                populateFilterOptions(cachedGanttDataMain, true);
                // Sync selected filters
                selectedFiltersFullscreen = new Set(selectedFilters);
                // Update checkboxes to match
                document.querySelectorAll('#ganttFilterOptionsFullscreen input[type="checkbox"]').forEach(cb => {
                    const label = decodeURIComponent(cb.value);
                    cb.checked = selectedFiltersFullscreen.has(label);
                });
                updateFilterText(true);
                applyFilterAndRenderFullscreen();
            } else {
                onGroupByChangeFullscreen();
            }
        }

        function closeGanttFullscreen() {
            const modal = document.getElementById('ganttFullscreenModal');
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }

        async function updateGanttChartFullscreen() {
            let groupByFields = getSelectedGroupByFields(true);
            if (groupByFields.length === 0) {
                groupByFields = ['ProjectID'];
            }
            const groupBy = groupByFields.join(',');

            try {
                const data = await fetchGanttData(groupBy);

                if (data) {
                    cachedGanttDataMain = data;
                    populateFilterOptions(data, true);
                    renderGanttChartFullscreen(data);
                } else {
                    document.getElementById('ganttFullscreenBody').innerHTML =
                        '<div class="gantt-empty">No warranty data available</div>';
                }
            } catch (error) {
                console.error('Error in updateGanttChartFullscreen:', error);
                document.getElementById('ganttFullscreenBody').innerHTML =
                    '<div class="gantt-empty">Error loading warranty data</div>';
            }
        }

        function renderGanttChartFullscreen(data) {
            const container = document.getElementById('ganttFullscreenBody');

            if (!data || !data.items || data.items.length === 0) {
                container.innerHTML = '<div class="gantt-empty">No warranty data available</div>';
                return;
            }

            // Parse dates as UTC to avoid timezone issues
            const minDate = parseDateUTC(data.min_date);
            const maxDate = parseDateUTC(data.max_date);
            const today = parseDateUTC(data.today);

            if (!minDate || !maxDate) {
                container.innerHTML = '<div class="gantt-empty">Invalid date range</div>';
                return;
            }

            // Calculate total time span in days
            const totalDays = Math.round((maxDate - minDate) / (1000 * 60 * 60 * 24));

            // Generate month markers with their day counts and percentages
            const months = [];
            let currentYear = minDate.getUTCFullYear();
            let currentMonthNum = minDate.getUTCMonth();

            while (true) {
                const monthStart = new Date(Date.UTC(currentYear, currentMonthNum, 1));
                const nextMonthStart = new Date(Date.UTC(currentYear, currentMonthNum + 1, 1));

                if (monthStart >= maxDate) break;

                const effectiveStart = monthStart < minDate ? minDate : monthStart;
                const effectiveEnd = nextMonthStart > maxDate ? maxDate : nextMonthStart;
                const daysInThisMonth = Math.round((effectiveEnd - effectiveStart) / (1000 * 60 * 60 * 24));
                const widthPercent = (daysInThisMonth / totalDays) * 100;

                months.push({
                    date: monthStart,
                    label: monthStart.toLocaleDateString('en-US', { month: 'short', year: '2-digit', timeZone: 'UTC' }),
                    days: daysInThisMonth,
                    widthPercent: widthPercent
                });

                currentMonthNum++;
                if (currentMonthNum > 11) {
                    currentMonthNum = 0;
                    currentYear++;
                }
            }

            // Generate month lines HTML for rows with proper widths
            const monthLinesHtml = '<div class="gantt-month-lines">' +
                months.map(m => `<div class="gantt-month-line" style="flex: 0 0 ${m.widthPercent}%; width: ${m.widthPercent}%;"></div>`).join('') +
                '</div>';

            // Generate body-level month lines with proper widths
            const bodyMonthLinesHtml = '<div class="gantt-body-month-lines">' +
                months.map(m => `<div class="gantt-body-month-line" style="flex: 0 0 ${m.widthPercent}%; width: ${m.widthPercent}%;"></div>`).join('') +
                '</div>';

            // Group items by label for display
            const groupedItems = {};
            data.items.forEach(item => {
                if (!groupedItems[item.label]) {
                    groupedItems[item.label] = [];
                }
                groupedItems[item.label].push(item);
            });

            // Build HTML
            let html = '<div class="gantt-chart">';

            // Header with months - use proportional widths
            html += '<div class="gantt-header">';
            html += '<div class="gantt-label-header">Item</div>';
            html += '<div class="gantt-timeline-header">';
            months.forEach(month => {
                html += `<div class="gantt-month" style="flex: 0 0 ${month.widthPercent}%; width: ${month.widthPercent}%;">${month.label}</div>`;
            });
            html += '</div></div>';

            // Body with rows
            html += '<div class="gantt-body">';
            html += bodyMonthLinesHtml;

            Object.keys(groupedItems).sort().forEach(label => {
                // Apply aggregation if enabled
                const items = aggregateBarsMode ? aggregateItems(groupedItems[label]) : groupedItems[label];

                // Calculate weighted average date for this group
                const avgPercent = calculateWeightedAvgDate(items, minDate, totalDays);

                // Assign bars to rows - non-overlapping bars share the same row
                const barHeightFS = 28;
                const barGapFS = 0;
                const topPaddingFS = 0;
                const bottomPaddingFS = 0;

                // Use serial_group directly as row number (Buy and Sell from same warranty share same serial_group)
                const itemRowsFS = [];
                let maxRowFS = 0;

                items.forEach((item, idx) => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);
                    if (startDate && endDate && startDate <= endDate) {
                        const row = typeof item.serial_group === 'number' ? item.serial_group : idx;
                        itemRowsFS[idx] = row;
                        if (row > maxRowFS) maxRowFS = row;
                    } else {
                        itemRowsFS[idx] = -1;
                    }
                });

                const numRowsFS = maxRowFS + 1;
                const rowTimelineHeightFS = numRowsFS * barHeightFS;

                html += `<div class="gantt-row">`;
                html += `<div class="gantt-row-label" title="${label}">${label}</div>`;
                html += `<div class="gantt-row-timeline" style="height: ${rowTimelineHeightFS}px;">`;
                html += monthLinesHtml;

                items.forEach((item, idx) => {
                    const startDate = parseDateUTC(item.start);
                    const endDate = parseDateUTC(item.end);
                    const dataAttrs = `data-label="${encodeURIComponent(label)}" data-start="${item.start || ''}" data-end="${item.end || ''}" data-volume="${item.volume}" data-fullscreen="true"`;

                    if (startDate && endDate && startDate <= endDate && itemRowsFS[idx] >= 0) {
                        // Calculate position and width using UTC dates
                        const startOffset = Math.round((startDate - minDate) / (1000 * 60 * 60 * 24));
                        const endOffset = Math.round((endDate - minDate) / (1000 * 60 * 60 * 24)) + 1;

                        const leftPercent = (startOffset / totalDays) * 100;
                        const widthPercent = ((endOffset - startOffset) / totalDays) * 100;

                        // Calculate top position based on assigned row
                        const topPositionFS = itemRowsFS[idx] * barHeightFS;

                        // Create tooltip text
                        const periodLabel = item.period_type === 'sell' ? 'Sell' : 'Buy';
                        const tooltipText = `${label}\n${periodLabel} Warranty\nStart: ${item.start}\nEnd: ${item.end}\nVolume: ${item.volume}\nClick to view credits`;

                        const aggregateSellStyleFS = (aggregateBarsMode && item.period_type === 'sell') ? ' padding: 0;' : '';
                        html += `<div class="gantt-bar ${item.status} ${item.period_type || 'buy'}"
                            style="left: ${leftPercent}%; width: ${widthPercent}%; top: ${topPositionFS}px;${aggregateSellStyleFS}"
                            title="${tooltipText}" ${dataAttrs} data-period-type="${item.period_type || 'buy'}"
                            onclick="showCreditsDialogFullscreen(this)">${item.volume}</div>`;
                    }
                });

                html += '</div>'; // Close timeline

                // Add weighted average line (positioned relative to row, after 200px label)
                if (avgPercent !== null && avgPercent >= 0 && avgPercent <= 100) {
                    html += `<div class="gantt-avg-line" style="left: calc(200px + (100% - 200px) * ${avgPercent / 100});" title="Weighted avg warranty date"></div>`;
                }

                html += '</div>'; // Close row
            });

            // Add today line - position relative to timeline area (after 200px label)
            // Add +1 day to align with end of bars that end today (same logic as bar endOffset)
            const todayOffset = Math.round((today - minDate) / (1000 * 60 * 60 * 24)) + 1;
            const todayPercent = (todayOffset / totalDays) * 100;
            if (todayPercent >= 0 && todayPercent <= 100) {
                html += `<div class="gantt-today-line" style="left: calc(200px + (100% - 200px) * ${todayPercent / 100})" title="Today"></div>`;
            }

            html += '</div></div>';

            container.innerHTML = html;
        }

        async function showCreditsDialogFullscreen(barElement) {
            const label = decodeURIComponent(barElement.dataset.label);
            const startDate = barElement.dataset.start;
            const endDate = barElement.dataset.end;
            const periodType = barElement.dataset.periodType || 'buy';

            // Get current group by fields from fullscreen (multi-select)
            const groupByFields = getSelectedGroupByFields(true);

            // Fetch warranty data to get matching credits
            try {
                const response = await fetch('/api/warranties/get');
                if (!response.ok) throw new Error('Failed to fetch warranties');
                const warrantyData = await response.json();

                // Filter credits that match this bar based on period type (Buy or Sell)
                const matchingCredits = warrantyData.data.filter(item => {
                    // Build composite group key from multiple fields (same as backend)
                    const keyParts = [];
                    for (const field of groupByFields) {
                        const value = item[field];
                        if (!value || String(value).trim() === '') {
                            return false; // Skip items with empty group field values
                        }
                        keyParts.push(String(value).trim());
                    }
                    const itemGroupValue = keyParts.join(' | ');

                    // Check if group label matches
                    if (itemGroupValue !== label) return false;

                    let itemStart, itemEnd;
                    if (periodType === 'sell') {
                        itemStart = item.Sell_Start || '';
                        itemEnd = item.Sell_End || '';
                    } else {
                        itemStart = item.Buy_Start || '';
                        itemEnd = item.Buy_End || '';
                    }

                    // In aggregate mode, match all items with valid dates for this period type
                    if (aggregateBarsMode) {
                        return itemStart !== '' && itemEnd !== '';
                    }

                    // In normal mode, match exact dates
                    return itemStart === startDate && itemEnd === endDate;
                });

                // Update dialog title and subtitle
                document.getElementById('creditsDialogTitle').textContent = label;
                const periodLabel = periodType === 'sell' ? 'Sell' : 'Buy';
                let subtitle = '';
                if (startDate && endDate) {
                    subtitle = `${periodLabel} Warranty Period: ${startDate} to ${endDate}`;
                } else {
                    subtitle = 'No warranty dates set';
                }
                document.getElementById('creditsDialogSubtitle').textContent = subtitle;

                // Group credits by serial range
                const groupedCredits = groupSerialsByRange(matchingCredits);

                // Populate table
                const tbody = document.getElementById('creditsDialogBody');
                if (groupedCredits.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="18" style="text-align: center; color: #999;">No credits found</td></tr>';
                } else {
                    tbody.innerHTML = groupedCredits.map(group => `
                        <tr>
                            <td title="${group.serialRange}">${group.serialRange}</td>
                            <td><strong>${group.count}</strong></td>
                            <td>${group.market}</td>
                            <td>${group.registry}</td>
                            <td>${group.product}</td>
                            <td>${group.projectId}</td>
                            <td>${group.projectName}</td>
                            <td>${group.projectType}</td>
                            <td>${group.protocol}</td>
                            <td>${group.vintage}</td>
                            <td>${group.buyStart}</td>
                            <td>${group.buyEnd}</td>
                            <td>${group.buyTradeId}</td>
                            <td>${group.buyClient}</td>
                            <td>${group.sellStart}</td>
                            <td>${group.sellEnd}</td>
                            <td>${group.sellTradeId}</td>
                            <td>${group.sellClient}</td>
                        </tr>
                    `).join('');
                }

                // Update count
                document.getElementById('creditsDialogCount').textContent = matchingCredits.length;

                // Show dialog
                document.getElementById('creditsDialogOverlay').classList.add('active');

            } catch (error) {
                console.error('Error fetching credits:', error);
                alert('Failed to load credits data');
            }
        }

        // Close fullscreen on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeGanttFullscreen();
                closeCreditsDialog();
            }
        });

        // Credits Dialog Functions
        function groupSerialsByRange(credits) {
            // Group credits by common attributes (excluding Serial)
            const groups = {};

            credits.forEach(credit => {
                const key = `${credit.Market || ''}|${credit.Registry || ''}|${credit.Product || ''}|${credit.ProjectID || ''}|${credit.ProjectName || ''}|${credit.ProjectType || ''}|${credit.Protocol || ''}|${credit.Vintage || ''}|${credit.Buy_Start || ''}|${credit.Buy_End || ''}|${credit.Buy_TradeID || ''}|${credit.Buy_Client || ''}|${credit.Sell_Start || ''}|${credit.Sell_End || ''}|${credit.Sell_TradeID || ''}|${credit.Sell_Client || ''}`;

                if (!groups[key]) {
                    groups[key] = {
                        serials: [],
                        market: credit.Market || '-',
                        registry: credit.Registry || '-',
                        product: credit.Product || '-',
                        projectId: credit.ProjectID || '-',
                        projectName: credit.ProjectName || '-',
                        projectType: credit.ProjectType || '-',
                        protocol: credit.Protocol || '-',
                        vintage: credit.Vintage || '-',
                        buyStart: credit.Buy_Start || '-',
                        buyEnd: credit.Buy_End || '-',
                        buyTradeId: credit.Buy_TradeID || '-',
                        buyClient: credit.Buy_Client || '-',
                        sellStart: credit.Sell_Start || '-',
                        sellEnd: credit.Sell_End || '-',
                        sellTradeId: credit.Sell_TradeID || '-',
                        sellClient: credit.Sell_Client || '-'
                    };
                }
                groups[key].serials.push(credit.Serial);
            });

            // Convert to array and create serial ranges
            return Object.values(groups).map(group => {
                // Sort serials
                const sortedSerials = group.serials.sort();
                const ranges = [];
                let rangeStart = null;
                let rangeEnd = null;
                let prevSerial = null;

                // Try to detect consecutive serials
                sortedSerials.forEach((serial, idx) => {
                    if (rangeStart === null) {
                        rangeStart = serial;
                        rangeEnd = serial;
                    } else {
                        // Check if this serial is "consecutive" to the previous one
                        // Simple heuristic: if they share a common prefix and differ only in suffix numbers
                        const isConsecutive = areConsecutiveSerials(prevSerial, serial);

                        if (isConsecutive) {
                            rangeEnd = serial;
                        } else {
                            // Save current range and start new one
                            if (rangeStart === rangeEnd) {
                                ranges.push(rangeStart);
                            } else {
                                ranges.push(`${rangeStart} - ${rangeEnd}`);
                            }
                            rangeStart = serial;
                            rangeEnd = serial;
                        }
                    }
                    prevSerial = serial;
                });

                // Don't forget the last range
                if (rangeStart !== null) {
                    if (rangeStart === rangeEnd) {
                        ranges.push(rangeStart);
                    } else {
                        ranges.push(`${rangeStart} - ${rangeEnd}`);
                    }
                }

                return {
                    serialRange: ranges.length > 3 ? `${ranges[0]}, ... (${ranges.length} ranges)` : ranges.join(', '),
                    count: group.serials.length,
                    market: group.market,
                    registry: group.registry,
                    product: group.product,
                    projectId: group.projectId,
                    projectName: group.projectName,
                    projectType: group.projectType,
                    protocol: group.protocol,
                    vintage: group.vintage,
                    buyStart: group.buyStart,
                    buyEnd: group.buyEnd,
                    buyTradeId: group.buyTradeId,
                    buyClient: group.buyClient,
                    sellStart: group.sellStart,
                    sellEnd: group.sellEnd,
                    sellTradeId: group.sellTradeId,
                    sellClient: group.sellClient
                };
            });
        }

        function areConsecutiveSerials(serial1, serial2) {
            if (!serial1 || !serial2) return false;

            // Extract numeric suffixes
            const match1 = serial1.match(/^(.+?)(\d+)$/);
            const match2 = serial2.match(/^(.+?)(\d+)$/);

            if (match1 && match2 && match1[1] === match2[1]) {
                const num1 = parseInt(match1[2]);
                const num2 = parseInt(match2[2]);
                return num2 === num1 + 1;
            }
            return false;
        }

        async function showCreditsDialog(barElement) {
            const label = decodeURIComponent(barElement.dataset.label);
            const startDate = barElement.dataset.start;
            const endDate = barElement.dataset.end;
            const volume = barElement.dataset.volume;
            const periodType = barElement.dataset.periodType || 'buy';

            // Get current group by fields (multi-select)
            const groupByFields = getSelectedGroupByFields(false);

            // Fetch warranty data to get matching credits
            try {
                const response = await fetch('/api/warranties/get');
                if (!response.ok) throw new Error('Failed to fetch warranties');
                const warrantyData = await response.json();

                // Filter credits that match this bar based on period type (Buy or Sell)
                const matchingCredits = warrantyData.data.filter(item => {
                    // Build composite group key from multiple fields (same as backend)
                    const keyParts = [];
                    for (const field of groupByFields) {
                        const value = item[field];
                        if (!value || String(value).trim() === '') {
                            return false; // Skip items with empty group field values
                        }
                        keyParts.push(String(value).trim());
                    }
                    const itemGroupValue = keyParts.join(' | ');

                    // Check if group label matches
                    if (itemGroupValue !== label) return false;

                    let itemStart, itemEnd;
                    if (periodType === 'sell') {
                        itemStart = item.Sell_Start || '';
                        itemEnd = item.Sell_End || '';
                    } else {
                        itemStart = item.Buy_Start || '';
                        itemEnd = item.Buy_End || '';
                    }

                    // In aggregate mode, match all items with valid dates for this period type
                    if (aggregateBarsMode) {
                        return itemStart !== '' && itemEnd !== '';
                    }

                    // In normal mode, match exact dates
                    return itemStart === startDate && itemEnd === endDate;
                });

                // Update dialog title and subtitle
                document.getElementById('creditsDialogTitle').textContent = label;
                const periodLabel = periodType === 'sell' ? 'Sell' : 'Buy';
                let subtitle = '';
                if (startDate && endDate) {
                    subtitle = `${periodLabel} Warranty Period: ${startDate} to ${endDate}`;
                } else {
                    subtitle = 'No warranty dates set';
                }
                document.getElementById('creditsDialogSubtitle').textContent = subtitle;

                // Group credits by serial range
                const groupedCredits = groupSerialsByRange(matchingCredits);

                // Populate table
                const tbody = document.getElementById('creditsDialogBody');
                if (groupedCredits.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="18" style="text-align: center; color: #999;">No credits found</td></tr>';
                } else {
                    tbody.innerHTML = groupedCredits.map(group => `
                        <tr>
                            <td title="${group.serialRange}">${group.serialRange}</td>
                            <td><strong>${group.count}</strong></td>
                            <td>${group.market}</td>
                            <td>${group.registry}</td>
                            <td>${group.product}</td>
                            <td>${group.projectId}</td>
                            <td>${group.projectName}</td>
                            <td>${group.projectType}</td>
                            <td>${group.protocol}</td>
                            <td>${group.vintage}</td>
                            <td>${group.buyStart}</td>
                            <td>${group.buyEnd}</td>
                            <td>${group.buyTradeId}</td>
                            <td>${group.buyClient}</td>
                            <td>${group.sellStart}</td>
                            <td>${group.sellEnd}</td>
                            <td>${group.sellTradeId}</td>
                            <td>${group.sellClient}</td>
                        </tr>
                    `).join('');
                }

                // Update count
                document.getElementById('creditsDialogCount').textContent = matchingCredits.length;

                // Show dialog
                document.getElementById('creditsDialogOverlay').classList.add('active');
                document.body.style.overflow = 'hidden';

            } catch (error) {
                console.error('Error fetching credits:', error);
                alert('Failed to load credits data');
            }
        }

        function closeCreditsDialog(event) {
            // If called from overlay click, only close if clicking the overlay itself
            if (event && event.target !== event.currentTarget) return;

            document.getElementById('creditsDialogOverlay').classList.remove('active');
            if (!document.getElementById('ganttFullscreenModal').classList.contains('active')) {
                document.body.style.overflow = '';
            }
        }
    </script>
</body>
</html>
