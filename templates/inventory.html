<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory Management - Carbon IMS</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)),
                        url('/static/bg-forest.jpg') center/cover no-repeat fixed;
        }

        .container {
            max-width: none;
            width: 100%;
            height: 100vh;
            padding: 0;
            display: flex;
            align-items: stretch;
        }

        .inventory-box {
            background: white;
            padding: 30px;
            width: 100%;
            height: 100vh;
            max-width: none;
            border-radius: 0;
            box-shadow: none;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .user-management-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .users-table {
            flex: 1;
            overflow: auto;
        }

        table {
            font-size: 13px;
            table-layout: auto;
            width: 100%;
        }

        thead th {
            padding: 8px 10px !important;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
        }

        tbody td {
            padding: 6px 10px !important;
            white-space: nowrap;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .editable {
            cursor: text;
            padding: 4px !important;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .editable:hover {
            background-color: #e9ecef;
        }

        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            gap: 15px;
            flex-wrap: wrap;
        }

        .pagination-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pagination-controls select {
            padding: 6px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 13px;
            background-color: white;
        }

        .pagination-controls button {
            padding: 6px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            background-color: white;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .pagination-controls button:hover:not(:disabled) {
            background-color: #667eea;
            color: white;
            border-color: #667eea;
        }

        .pagination-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination-info {
            font-size: 13px;
            color: #666;
        }

        .sortable-header {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px !important;
        }

        .sortable-header:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .sort-indicator {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
        }

        .filter-row input {
            width: 100%;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
        }

        .filter-row {
            background-color: #f8f9fa;
        }

        .filter-row td {
            padding: 5px !important;
        }

        .editing {
            background-color: #fff3cd;
            border: 2px solid #ffc107;
            padding: 5px;
        }

        .modified-row {
            background-color: #fff3cd;
        }

        .modified-row:hover {
            background-color: #ffe69c !important;
        }

        .added-row {
            background-color: #d4edda;
        }

        .added-row:hover {
            background-color: #c3e6cb !important;
        }

        .deleted-row {
            background-color: #f8d7da;
            opacity: 0.7;
            text-decoration: line-through;
        }

        .deleted-row:hover {
            background-color: #f5c6cb !important;
        }

        .btn-add {
            background-color: #28a745;
            color: white;
            font-size: 14px;
        }

        .btn-add:hover {
            background-color: #218838;
        }

        .changes-indicator {
            display: inline-block;
            margin-left: 10px;
            padding: 8px 15px;
            background-color: #ffc107;
            color: #333;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
        }

        .no-changes {
            opacity: 0.5;
            background-color: #6c757d;
            color: white;
        }

        .btn-commit {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }

        .btn-commit:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }

        .btn-commit:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-discard {
            background-color: #dc3545;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }

        .btn-discard:hover {
            background-color: #c82333;
            transform: translateY(-2px);
        }

        .btn-discard:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .backup-group {
            margin-bottom: 25px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }

        .backup-group-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .backup-group-header h4 {
            margin: 0;
            font-size: 16px;
        }

        .backup-group-body {
            padding: 0;
        }

        .backup-item {
            padding: 15px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }

        .backup-item:last-child {
            border-bottom: none;
        }

        .backup-item:hover {
            background-color: #f8f9fa;
        }

        .backup-info {
            flex: 1;
        }

        .backup-time {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .backup-meta {
            font-size: 13px;
            color: #666;
        }

        .backup-actions {
            display: flex;
            gap: 8px;
        }

        .btn-icon {
            padding: 8px 15px;
            font-size: 14px;
        }

        #summaryModal {
            z-index: 1100;
        }

        .custom-alert-modal, .custom-confirm-modal {
            z-index: 2000;
        }

        .custom-alert-modal .modal-content,
        .custom-confirm-modal .modal-content {
            max-width: 500px;
            animation: slideDown 0.2s ease-out;
        }

        .dialog-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 15px;
        }

        .dialog-icon.success { color: #28a745; }
        .dialog-icon.error { color: #dc3545; }
        .dialog-icon.warning { color: #ffc107; }
        .dialog-icon.info { color: #007bff; }

        .dialog-message {
            text-align: center;
            font-size: 16px;
            color: #333;
            line-height: 1.5;
            margin-bottom: 20px;
            white-space: pre-line;
        }

        .dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        /* Progress Modal Styles */
        .progress-modal {
            z-index: 2500 !important;
        }

        .progress-modal .modal-content {
            max-width: 450px;
            text-align: center;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar-wrapper {
            background: #e9ecef;
            border-radius: 10px;
            height: 24px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 10px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }

        .progress-status {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }

        .progress-detail {
            font-size: 12px;
            color: #999;
        }

        .progress-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #e9ecef;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .summary-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 20px 0;
        }

        .summary-item {
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid;
        }

        .summary-item.modified {
            background-color: #fff3cd;
            border-left-color: #ffc107;
        }

        .summary-item.added {
            background-color: #d4edda;
            border-left-color: #28a745;
        }

        .summary-item.deleted {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }

        .summary-item-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
        }

        .summary-item-details {
            font-size: 13px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="inventory-box">
            <header class="home-header">
                <h1>Inventory Management</h1>
                <div class="header-actions">
                    <a href="{{ url_for('auth.home') }}" class="btn-secondary">Back to Home</a>
                    <a href="{{ url_for('auth.logout') }}" class="btn-logout">Logout</a>
                </div>
            </header>

            {% with messages = get_flashed_messages(with_categories=true) %}
                {% if messages %}
                    {% for category, message in messages %}
                        <div class="alert alert-{{ category }}">
                            {{ message }}
                        </div>
                    {% endfor %}
                {% endif %}
            {% endwith %}

            <div class="user-management-section">
                <div class="section-header">
                    <h2>Current Inventory
                        {% if user_role == 'ops' %}
                        <span class="changes-indicator" style="background-color: #17a2b8; color: white;">Read-Only Mode</span>
                        {% else %}
                        <span class="changes-indicator no-changes" id="changesIndicator">No pending changes</span>
                        {% endif %}
                    </h2>
                    <div style="display: flex; gap: 10px;">
                        {% if user_role != 'ops' %}
                        <button class="btn-discard" id="discardBtn" onclick="discardChanges()" disabled>Discard Changes</button>
                        <button class="btn-commit" id="commitBtn" onclick="showCommitSummary()" disabled>Save Changes</button>
                        {% endif %}
                        {% if user_role == 'admin' %}
                        <button class="btn-secondary" onclick="showBackups()">View Backups</button>
                        <button class="btn-secondary" onclick="showImportCSV()">Import to Database</button>
                        {% endif %}
                        {% if user_role != 'ops' %}
                        <button class="btn-primary btn-add" onclick="addNewRow()">Add New Item</button>
                        <button class="btn-danger" onclick="showBulkDelete()">Bulk Delete</button>
                        {% endif %}
                    </div>
                </div>

                <div class="table-controls">
                    <div class="pagination-controls">
                        <label>View Mode:</label>
                        <select id="viewMode" onchange="changeViewMode()">
                            <option value="raw" {% if view_mode == 'raw' %}selected{% endif %}>By Serial</option>
                            <option value="summarized" {% if view_mode == 'summarized' %}selected{% endif %}>Summarized</option>
                        </select>
                        <label style="margin-left: 20px;">Custody View:</label>
                        <select id="custodyView" onchange="changeCustodyView()">
                            <option value="all" {% if custody_view == 'all' %}selected{% endif %}>Show All</option>
                            <option value="true" {% if custody_view == 'true' %}selected{% endif %}>In Custody</option>
                            <option value="false" {% if custody_view == 'false' %}selected{% endif %}>Available</option>
                        </select>
                        <label style="margin-left: 20px;">Rows per page:</label>
                        <select id="rowsPerPage" onchange="changeRowsPerPage()">
                            <option value="all" {% if rows_per_page == 'all' %}selected{% endif %}>All</option>
                            <option value="10" {% if rows_per_page == '10' %}selected{% endif %}>10</option>
                            <option value="25" {% if rows_per_page == '25' %}selected{% endif %}>25</option>
                            <option value="50" {% if rows_per_page == '50' %}selected{% endif %}>50</option>
                            <option value="100" {% if rows_per_page == '100' %}selected{% endif %}>100</option>
                        </select>
                        <span class="pagination-info" id="paginationInfo">Showing all records</span>
                        <span class="pagination-info" id="rowCountInfo" style="margin-left: auto; padding: 4px 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 4px; font-weight: 500;"></span>
                    </div>
                    <div class="pagination-controls">
                        <button class="btn-primary" onclick="showAdvancedSort()" style="padding: 8px 16px; font-size: 14px; white-space: nowrap;">Advanced Sort</button>
                        <button class="btn-primary" onclick="clearFilters()" style="padding: 8px 16px; font-size: 14px; white-space: nowrap;">Clear Filters</button>
                        <button class="btn-primary" onclick="exportToExcel()" style="padding: 8px 16px; font-size: 14px; white-space: nowrap;">Export to Excel</button>
                        <button id="prevPage" onclick="changePage(-1)" disabled>Previous</button>
                        <div id="pageNavigation" style="display: inline-flex; align-items: center; gap: 8px; font-size: 14px;">
                            <span style="font-size: 14px;">Page</span>
                            <input type="number" id="pageInput" min="1" value="1" style="width: 60px; padding: 6px; text-align: center; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;" onkeypress="handlePageInputEnter(event)">
                            <span style="font-size: 14px;">of</span>
                            <span id="totalPages" style="font-size: 14px;">1</span>
                            <button onclick="goToPage()" style="padding: 6px 12px; font-size: 14px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 500; transition: background-color 0.3s;" onmouseover="this.style.backgroundColor='#0056b3'" onmouseout="this.style.backgroundColor='#007bff'">Go</button>
                        </div>
                        <button id="nextPage" onclick="changePage(1)" disabled>Next</button>
                    </div>
                </div>

                <div class="users-table">
                    <table id="inventoryTable">
                        <thead id="tableHead">
                            <tr>
                                <th>Loading...</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                            <tr>
                                <td colspan="100%">Loading inventory data...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Commit Summary Modal -->
            <div id="commitModal" class="modal">
                <div class="modal-content" style="max-width: 700px;">
                    <div class="modal-header">
                        <h3>Confirm Changes</h3>
                        <span class="close" onclick="closeCommitModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <p style="color: #666; margin-bottom: 10px;">
                            Please review the following changes before committing:
                        </p>
                        <div id="changeSummary" class="summary-list">
                            <!-- Summary will be populated here -->
                        </div>
                        <div class="form-actions" style="justify-content: flex-end; margin-top: 20px;">
                            <button class="btn-secondary" onclick="closeCommitModal()">Cancel</button>
                            <button class="btn-commit" onclick="commitChanges()">Commit Changes</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Backup Summary Modal -->
            <div id="summaryModal" class="modal">
                <div class="modal-content" style="max-width: 700px;">
                    <div class="modal-header">
                        <h3 id="summaryModalTitle">Change Summary</h3>
                        <span class="close" onclick="closeSummaryModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div id="backupSummaryContent" class="summary-list">
                            <!-- Summary will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Advanced Sort Modal -->
            <div id="advancedSortModal" class="modal">
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <h3>Advanced Sort</h3>
                        <span class="close" onclick="closeAdvancedSort()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <p style="color: #666; margin-bottom: 15px;">
                            Configure multi-level sorting for the inventory table.
                        </p>
                        <div id="sortLevelsContainer">
                            <!-- Sort levels will be added here -->
                        </div>
                        <button class="btn-secondary" onclick="addSortLevel()" style="margin-top: 10px;">Add Sort Level</button>
                        <div class="form-actions" style="justify-content: flex-end; margin-top: 20px;">
                            <button class="btn-secondary" onclick="clearSort()">Clear All</button>
                            <button class="btn-secondary" onclick="closeAdvancedSort()">Cancel</button>
                            <button class="btn-commit" onclick="applyAdvancedSort()">Apply Sort</button>
                        </div>
                    </div>
                </div>
            </div>

            {% if user_role == 'admin' %}
            <!-- Backup Modal -->
            <div id="backupModal" class="modal">
                <div class="modal-content" style="max-width: 900px;">
                    <div class="modal-header">
                        <h3>Inventory Backups</h3>
                        <span class="close" onclick="closeBackupModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <p style="color: #666; margin-bottom: 20px;">
                            Backups are created automatically after each edit. You can restore to any previous version or delete old backups.
                        </p>
                        <div id="backupListContainer">
                            <div id="backupGroupsContainer">
                                <p style="text-align: center; color: #666;">Loading backups...</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Import CSV Modal -->
            <div id="importCSVModal" class="modal">
                <div class="modal-content" style="max-width: 650px;">
                    <div class="modal-header">
                        <h3>Import to Database</h3>
                        <span class="close" onclick="closeImportCSV()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <p style="color: #666; margin-bottom: 20px;">
                            Import inventory and warranty data from a CSV file. The CSV should contain column headers matching the database fields.
                        </p>

                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="margin: 0; font-size: 14px; color: #495057;">Supported Columns:</h4>
                                <button class="btn-primary" onclick="downloadCSVTemplate()" style="padding: 6px 12px; font-size: 12px;">Download Template</button>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 13px;">
                                <div>
                                    <strong style="color: #28a745;">Inventory:</strong>
                                    <div style="color: #666; margin-top: 5px;">
                                        market, registry, product, project_id, project_type, protocol, project_name, vintage, serial, is_custody, is_assigned, trade_id
                                    </div>
                                </div>
                                <div>
                                    <strong style="color: #007bff;">Warranty:</strong>
                                    <div style="color: #666; margin-top: 5px;">
                                        buy_start, buy_end, sell_start, sell_end, buy_tradeid, sell_tradeid, buy_client, sell_client
                                    </div>
                                </div>
                            </div>
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #dee2e6; font-size: 12px; color: #6c757d;">
                                <strong>Note:</strong> The <code>serial</code> column is required. Column names are case-insensitive.
                            </div>
                        </div>

                        <div class="form-group" style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Select CSV File:</label>
                            <input type="file" id="csvFileInput" accept=".csv" style="width: 100%; padding: 10px; border: 2px dashed #dee2e6; border-radius: 8px; background: #f8f9fa; cursor: pointer;">
                            <div id="csvFileInfo" style="margin-top: 8px; font-size: 13px; color: #666;"></div>
                            <div id="csvValidationResult" style="margin-top: 8px; display: none;"></div>
                        </div>

                        <div class="form-group" style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Import Mode:</label>
                            <div style="display: flex; gap: 20px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 16px; border: 2px solid #dee2e6; border-radius: 8px; flex: 1; transition: all 0.2s;">
                                    <input type="radio" name="importMode" value="append" checked onchange="updateImportModeStyle()">
                                    <div>
                                        <div style="font-weight: 600; color: #28a745;">Append</div>
                                        <div style="font-size: 12px; color: #666;">Add new records, skip existing serials</div>
                                    </div>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 16px; border: 2px solid #dee2e6; border-radius: 8px; flex: 1; transition: all 0.2s;">
                                    <input type="radio" name="importMode" value="replace" onchange="updateImportModeStyle()">
                                    <div>
                                        <div style="font-weight: 600; color: #dc3545;">Replace All</div>
                                        <div style="font-size: 12px; color: #666;">Delete all existing data first</div>
                                    </div>
                                </label>
                            </div>
                        </div>

                        <div class="form-group" style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #856404;">
                                Enter Your Password to Confirm:
                            </label>
                            <input type="password" id="importPassword" placeholder="Enter your password" style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; font-size: 14px;">
                        </div>

                        <div id="importResultContainer" style="display: none; margin-bottom: 20px;"></div>

                        <div class="form-actions" style="justify-content: flex-end; gap: 10px;">
                            <button class="btn-secondary" onclick="closeImportCSV()">Cancel</button>
                            <button class="btn-commit" id="importCSVBtn" onclick="executeCSVImport()">Import</button>
                        </div>
                    </div>
                </div>
            </div>
            {% endif %}

            <!-- Custom Alert Modal -->
            <div id="customAlertModal" class="modal custom-alert-modal">
                <div class="modal-content">
                    <div class="modal-body">
                        <div class="dialog-icon success" id="alertIcon"></div>
                        <div class="dialog-message" id="alertMessage"></div>
                        <div class="dialog-buttons">
                            <button class="btn-commit" id="alertOkBtn" onclick="closeCustomAlert()">OK</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Progress Modal -->
            <div id="progressModal" class="modal progress-modal">
                <div class="modal-content">
                    <div class="modal-body">
                        <h3 style="margin-bottom: 20px; color: #333;">Saving Changes</h3>
                        <div class="progress-container">
                            <div class="progress-status" id="progressStatus">
                                <span class="progress-spinner"></span>
                                <span id="progressStatusText">Preparing...</span>
                            </div>
                            <div class="progress-bar-wrapper">
                                <div class="progress-bar-fill" id="progressBarFill" style="width: 0%;">
                                    <span id="progressPercent">0%</span>
                                </div>
                            </div>
                            <div class="progress-detail" id="progressDetail">Initializing...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Custom Confirm Modal -->
            <div id="customConfirmModal" class="modal custom-confirm-modal">
                <div class="modal-content">
                    <div class="modal-body">
                        <div class="dialog-icon warning" id="confirmIcon">⚠️</div>
                        <div class="dialog-message" id="confirmMessage"></div>
                        <div class="dialog-buttons">
                            <button class="btn-secondary" id="confirmCancelBtn" onclick="closeCustomConfirm(false)">Cancel</button>
                            <button class="btn-commit" id="confirmOkBtn" onclick="closeCustomConfirm(true)">Confirm</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Add New Item Modal -->
            <div id="addItemModal" class="modal">
                <div class="modal-content" style="max-width: 700px;">
                    <div class="modal-header">
                        <h3>Add New Item</h3>
                        <span class="close" onclick="closeAddItemModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 10px; font-weight: 600; color: #333;">Entry Mode:</label>
                            <div style="display: flex; gap: 20px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="radio" name="entryMode" value="single" checked onchange="toggleEntryMode()">
                                    <span>Single Item</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="radio" name="entryMode" value="group" onchange="toggleEntryMode()">
                                    <span>Group (Serial Range)</span>
                                </label>
                            </div>
                        </div>

                        <div id="addItemForm">
                            <!-- Form fields will be populated dynamically based on headers -->
                        </div>

                        <div class="form-actions" style="justify-content: flex-end; margin-top: 20px;">
                            <button class="btn-secondary" onclick="closeAddItemModal()">Cancel</button>
                            <button class="btn-success" onclick="submitAddItem()">Add Item(s)</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bulk Delete Modal -->
            <div id="bulkDeleteModal" class="modal">
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <h3>Bulk Delete by Serial Range</h3>
                        <span class="close" onclick="closeBulkDelete()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <p style="color: #666; margin-bottom: 20px;">
                            Enter serial numbers or ranges to delete. You can enter multiple values separated by commas.
                        </p>
                        <p style="color: #666; margin-bottom: 20px; font-size: 14px;">
                            <strong>Examples:</strong><br>
                            • Single: AB133311<br>
                            • Range: AB133311-AB133315<br>
                            • Multiple: AB133311, AB133315, AB133320-AB133325
                        </p>
                        <div class="form-group">
                            <label for="bulkDeleteInput">Serial Numbers / Ranges:</label>
                            <textarea id="bulkDeleteInput" rows="4" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 5px; font-size: 14px; font-family: monospace;" placeholder="AB133311, AB133315-AB133320, A2XCB1356"></textarea>
                        </div>
                        <div id="bulkDeletePreview" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; border: 1px solid #e0e0e0; display: none;">
                            <h4 style="margin: 0 0 10px 0; color: #333;">Preview:</h4>
                            <p id="bulkDeleteCount" style="margin: 0 0 10px 0; font-weight: 600; color: #dc3545;"></p>
                            <div id="bulkDeleteList" style="max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 13px;"></div>
                        </div>
                        <div id="bulkDeletePasswordSection" style="margin-top: 20px; display: none;">
                            <div class="form-group">
                                <label for="bulkDeletePassword" style="font-weight: 600; color: #dc3545;">Confirm Password to Delete:</label>
                                <input type="password" id="bulkDeletePassword" placeholder="Enter your password" style="width: 100%; padding: 12px; border: 2px solid #dc3545; border-radius: 5px; font-size: 14px;">
                            </div>
                        </div>
                        <div class="form-actions" style="justify-content: flex-end; margin-top: 20px;">
                            <button class="btn-secondary" onclick="closeBulkDelete()">Cancel</button>
                            <button class="btn-primary" onclick="previewBulkDelete()">Preview</button>
                            <button class="btn-danger" id="confirmBulkDeleteBtn" onclick="confirmBulkDelete()" style="display: none;">Delete Items</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Delete Row Confirmation Modal -->
            <div id="deleteRowModal" class="modal">
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h3>Confirm Delete</h3>
                        <span class="close" onclick="closeDeleteRowModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <p style="color: #666; margin-bottom: 20px;">
                            Are you sure you want to delete this item?
                        </p>
                        <div id="deleteRowInfo" style="padding: 15px; background: #f8f9fa; border-radius: 5px; border: 1px solid #e0e0e0; margin-bottom: 20px;">
                            <!-- Item info will be populated here -->
                        </div>
                        <div class="form-group">
                            <label for="deleteRowPassword" style="font-weight: 600; color: #dc3545;">Confirm Password to Delete:</label>
                            <input type="password" id="deleteRowPassword" placeholder="Enter your password" style="width: 100%; padding: 12px; border: 2px solid #dc3545; border-radius: 5px; font-size: 14px;" autocomplete="current-password">
                        </div>
                        <div class="form-actions" style="justify-content: flex-end; margin-top: 20px;">
                            <button class="btn-secondary" onclick="closeDeleteRowModal()">Cancel</button>
                            <button class="btn-danger" onclick="confirmDeleteRow()">Delete Item</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="app-footer"></div>

    <script>
        let inventoryData = [];
        let headers = [];
        let pendingChanges = {
            modified: {},  // row_index: { field: newValue, ... }
            added: [],     // array of new rows
            deleted: []    // array of row_indexes
        };
        let nextTempId = -1; // For temporary IDs for new rows

        // User role for access control
        const userRole = '{{ user_role }}';
        const isReadOnly = userRole === 'ops';

        // Pagination and filtering state
        let currentPage = 1;
        let rowsPerPage = '{{ rows_per_page }}';
        let columnFilters = {{ saved_filters | tojson | safe }};
        let sortConfig = {
            column: null,
            direction: null // 'asc' or 'desc'
        };
        let advancedSortLevels = [];
        let columnTypes = {}; // Store detected data type for each column
        let viewMode = '{{ view_mode }}'; // 'raw' or 'summarized'
        let serialColumnIndex = -1; // Index of the serial/ID column
        let custodyFilter = '{{ custody_view }}'; // 'all', 'true', or 'false'

        // Custom dialog state
        let confirmCallback = null;

        // Custom Alert Function
        function showAlert(message, type = 'info') {
            const modal = document.getElementById('customAlertModal');
            const icon = document.getElementById('alertIcon');
            const messageDiv = document.getElementById('alertMessage');

            // Set icon based on type
            icon.className = 'dialog-icon ' + type;
            switch (type) {
                case 'success':
                    icon.textContent = '✓';
                    break;
                case 'error':
                    icon.textContent = '✗';
                    break;
                case 'warning':
                    icon.textContent = '⚠️';
                    break;
                case 'info':
                default:
                    icon.textContent = 'ℹ';
                    break;
            }

            messageDiv.textContent = message;
            modal.style.display = 'flex';
        }

        function closeCustomAlert() {
            const modal = document.getElementById('customAlertModal');
            modal.style.display = 'none';
        }

        // Progress Modal Functions
        function showProgress() {
            const modal = document.getElementById('progressModal');
            modal.style.display = 'flex';
            updateProgress(0, 'Preparing...', 'Initializing...');
        }

        function hideProgress() {
            const modal = document.getElementById('progressModal');
            modal.style.display = 'none';
        }

        function updateProgress(percent, status, detail) {
            const fill = document.getElementById('progressBarFill');
            const percentText = document.getElementById('progressPercent');
            const statusText = document.getElementById('progressStatusText');
            const detailText = document.getElementById('progressDetail');

            fill.style.width = percent + '%';
            percentText.textContent = Math.round(percent) + '%';
            if (status) statusText.textContent = status;
            if (detail) detailText.textContent = detail;
        }

        // Custom Confirm Function
        function showConfirm(message, callback) {
            const modal = document.getElementById('customConfirmModal');
            const messageDiv = document.getElementById('confirmMessage');

            messageDiv.textContent = message;
            confirmCallback = callback;
            modal.style.display = 'flex';
        }

        function closeCustomConfirm(confirmed) {
            const modal = document.getElementById('customConfirmModal');
            modal.style.display = 'none';

            if (confirmCallback) {
                if (confirmed) {
                    confirmCallback();
                }
                confirmCallback = null;
            }
        }

        // Detect data type for a column based on its values
        function detectColumnType(columnName) {
            if (!inventoryData || inventoryData.length === 0) {
                return 'string';
            }

            let numCount = 0;
            let dateCount = 0;
            let totalNonEmpty = 0;

            // Sample up to 20 rows to determine type
            const sampleSize = Math.min(20, inventoryData.length);

            for (let i = 0; i < sampleSize; i++) {
                const value = inventoryData[i][columnName];
                if (!value || value.toString().trim() === '') continue;

                totalNonEmpty++;
                const strValue = value.toString().trim();

                // Check if it's a number
                if (!isNaN(strValue) && !isNaN(parseFloat(strValue))) {
                    numCount++;
                }

                // Check if it's a date (common formats)
                // Matches: YYYY-MM-DD, DD/MM/YYYY, MM/DD/YYYY, etc.
                const datePatterns = [
                    /^\d{4}-\d{2}-\d{2}/, // YYYY-MM-DD
                    /^\d{1,2}\/\d{1,2}\/\d{2,4}/, // MM/DD/YYYY or DD/MM/YYYY
                    /^\d{1,2}-\d{1,2}-\d{2,4}/, // MM-DD-YYYY or DD-MM-YYYY
                ];

                if (datePatterns.some(pattern => pattern.test(strValue))) {
                    const testDate = new Date(strValue);
                    if (!isNaN(testDate.getTime())) {
                        dateCount++;
                    }
                }
            }

            if (totalNonEmpty === 0) return 'string';

            // If 80% or more are numbers, treat as number
            if (numCount / totalNonEmpty >= 0.8) {
                return 'number';
            }

            // If 80% or more are dates, treat as date
            if (dateCount / totalNonEmpty >= 0.8) {
                return 'date';
            }

            return 'string';
        }

        // Detect all column types
        function detectAllColumnTypes() {
            columnTypes = {};
            headers.forEach(header => {
                columnTypes[header] = detectColumnType(header);
            });
        }

        // Compare values based on their data type
        function compareValues(aVal, bVal, dataType, direction) {
            // Handle empty values
            if (!aVal && !bVal) return 0;
            if (!aVal) return 1;
            if (!bVal) return -1;

            let comparison = 0;

            if (dataType === 'number') {
                const aNum = parseFloat(aVal);
                const bNum = parseFloat(bVal);
                comparison = aNum - bNum;
            } else if (dataType === 'date') {
                const aDate = new Date(aVal);
                const bDate = new Date(bVal);
                comparison = aDate.getTime() - bDate.getTime();
            } else {
                // String comparison (case-insensitive)
                const aStr = aVal.toString().toLowerCase();
                const bStr = bVal.toString().toLowerCase();
                comparison = aStr.localeCompare(bStr);
            }

            return direction === 'asc' ? comparison : -comparison;
        }

        // Detect which column contains serial numbers or IDs
        function detectSerialColumn() {
            // Look for columns with names containing 'serial', 'id', 'item id', 'sku', etc.
            // Priority order: exact matches first, then partial matches
            const exactMatches = ['serial', 'serial number', 'serials'];
            const partialMatches = ['id', 'sku', 'item'];

            // First, try exact matches
            for (let i = 0; i < headers.length; i++) {
                const headerLower = headers[i].toLowerCase().trim();
                if (exactMatches.includes(headerLower)) {
                    serialColumnIndex = i;
                    console.log(`Serial column detected (exact match): "${headers[i]}" (index ${i})`);
                    return i;
                }
            }

            // Then try partial matches, but prefer columns that END with the keyword
            for (let i = 0; i < headers.length; i++) {
                const headerLower = headers[i].toLowerCase().trim();
                if (partialMatches.some(keyword => headerLower.endsWith(keyword))) {
                    serialColumnIndex = i;
                    console.log(`Serial column detected (ends with match): "${headers[i]}" (index ${i})`);
                    return i;
                }
            }

            // Finally, try any partial match
            for (let i = 0; i < headers.length; i++) {
                const headerLower = headers[i].toLowerCase().trim();
                if (partialMatches.some(keyword => headerLower.includes(keyword))) {
                    serialColumnIndex = i;
                    console.log(`Serial column detected (partial match): "${headers[i]}" (index ${i})`);
                    return i;
                }
            }

            // Default to last column if no match found (serials often at the end)
            serialColumnIndex = headers.length - 1;
            console.log(`Serial column defaulted to last column: "${headers[serialColumnIndex]}" (index ${serialColumnIndex})`);
            return serialColumnIndex;
        }

        // Parse serial number into prefix and ending numeric part
        // Serial always ends in numbers - we extract the ending number for range logic
        function parseSerial(serial) {
            if (!serial) return null;

            const str = serial.toString().trim();
            // Match pattern: anything followed by numbers at the end
            const match = str.match(/^(.*?)(\d+)$/);

            if (match) {
                return {
                    prefix: match[1],  // Everything before the ending numbers
                    number: parseInt(match[2]),  // The ending numbers
                    suffix: '',  // No suffix since numbers are at the end
                    original: str
                };
            }

            // If no ending numbers found, return null number
            return {
                prefix: str,
                number: null,
                suffix: '',
                original: str
            };
        }

        // Check if two serials are consecutive based on ending numbers only
        function areConsecutiveSerials(serial1, serial2) {
            const s1 = parseSerial(serial1);
            const s2 = parseSerial(serial2);

            if (!s1 || !s2 || s1.number === null || s2.number === null) {
                return false;
            }

            // Only check if ending numbers are consecutive (prefix doesn't need to match)
            return s2.number === s1.number + 1;
        }

        // Summarize data by grouping consecutive serials
        function summarizeData(data) {
            if (!data || data.length === 0) return [];

            detectSerialColumn();
            const serialColumn = headers[serialColumnIndex];

            // Group by all fields except serial column
            const groups = {};

            data.forEach(row => {
                // Create a key from all fields except serial
                // Normalize values (trim and lowercase) for better grouping
                const keyParts = [];
                headers.forEach((header, idx) => {
                    if (idx !== serialColumnIndex) {
                        const value = (row[header] || '').toString().trim().toLowerCase();
                        keyParts.push(value);
                    }
                });
                const groupKey = keyParts.join('|||');

                if (!groups[groupKey]) {
                    groups[groupKey] = {
                        fields: {},
                        serialToRows: {}, // Map serial -> array of row indices
                        serials: new Set() // Use Set to avoid duplicates
                    };
                    // Store the common field values (use original case/formatting for display)
                    headers.forEach((header, idx) => {
                        if (idx !== serialColumnIndex) {
                            groups[groupKey].fields[header] = row[header];
                        }
                    });
                }

                // Add serial to the set and map serial to row index
                const serialValue = row[serialColumn];
                if (serialValue) {
                    const trimmedSerial = serialValue.toString().trim();
                    groups[groupKey].serials.add(trimmedSerial);

                    // Track which rows have this serial
                    if (!groups[groupKey].serialToRows[trimmedSerial]) {
                        groups[groupKey].serialToRows[trimmedSerial] = [];
                    }
                    groups[groupKey].serialToRows[trimmedSerial].push(row._row_index);
                }
            });

            // Process each group to create serial ranges
            const summarized = [];

            // Debug: Show how many groups were created
            console.log('=== SUMMARIZATION DEBUG ===');
            console.log(`Total groups created: ${Object.keys(groups).length}`);
            console.log('Groups:', Object.keys(groups));

            Object.values(groups).forEach((group, groupIndex) => {
                // Convert Set to Array and sort serials by ending numbers
                // This allows different prefixes to be in the same consecutive range
                const sortedSerials = Array.from(group.serials).sort((a, b) => {
                    const pA = parseSerial(a);
                    const pB = parseSerial(b);
                    if (!pA || !pB) return 0;

                    // Sort primarily by ending number
                    if (pA.number !== null && pB.number !== null) {
                        if (pA.number !== pB.number) {
                            return pA.number - pB.number;
                        }
                        // If numbers are the same, sort by prefix
                        return pA.prefix.localeCompare(pB.prefix);
                    }

                    // Fallback to string comparison if no numbers
                    return a.toString().localeCompare(b.toString());
                });

                // Debug logging - show detailed group info
                console.log(`\nGroup ${groupIndex + 1}:`, {
                    fields: group.fields,
                    serialCount: sortedSerials.length,
                    serials: sortedSerials
                });

                // Group consecutive serials into ranges, tracking which serials are in each range
                const ranges = [];
                let currentRange = {
                    start: sortedSerials[0],
                    end: sortedSerials[0],
                    serials: [sortedSerials[0]]
                };

                for (let i = 1; i < sortedSerials.length; i++) {
                    if (areConsecutiveSerials(currentRange.end, sortedSerials[i])) {
                        currentRange.end = sortedSerials[i];
                        currentRange.serials.push(sortedSerials[i]);
                    } else {
                        // End current range, start new one
                        ranges.push(currentRange);
                        currentRange = {
                            start: sortedSerials[i],
                            end: sortedSerials[i],
                            serials: [sortedSerials[i]]
                        };
                    }
                }

                // Add final range
                ranges.push(currentRange);

                // Debug logging - show created ranges
                const rangeStrings = ranges.map(r => r.start === r.end ? r.start : `${r.start} - ${r.end}`);
                console.log(`  -> Created ${ranges.length} range(s):`, rangeStrings);

                // Create summarized row for each range
                ranges.forEach(rangeInfo => {
                    const summarizedRow = { ...group.fields };

                    // Set serial column to the range string
                    summarizedRow[serialColumn] = rangeInfo.start === rangeInfo.end
                        ? rangeInfo.start
                        : `${rangeInfo.start} - ${rangeInfo.end}`;

                    summarizedRow._row_index = -1000 - summarized.length; // Unique negative ID for summarized rows
                    summarizedRow._is_summarized = true;
                    summarizedRow._serials = rangeInfo.serials; // Store all serials for filtering

                    // Collect underlying rows for all serials in this range
                    const underlyingRows = [];
                    rangeInfo.serials.forEach(serial => {
                        const rowsForSerial = group.serialToRows[serial] || [];
                        underlyingRows.push(...rowsForSerial);
                    });
                    summarizedRow._underlying_rows = underlyingRows;

                    summarized.push(summarizedRow);
                });
            });

            return summarized;
        }

        // Change view mode
        function changeViewMode() {
            const select = document.getElementById('viewMode');
            viewMode = select.value;
            currentPage = 1; // Reset to first page
            renderTable();
        }

        function changeCustodyView() {
            const select = document.getElementById('custodyView');
            custodyFilter = select.value;
            currentPage = 1; // Reset to first page
            renderTable();
        }

        // Load inventory data on page load
        document.addEventListener('DOMContentLoaded', function() {
            // columnFilters is already initialized from saved_filters

            // Set UI elements to match user preferences
            const viewModeSelect = document.getElementById('viewMode');
            if (viewModeSelect) {
                viewModeSelect.value = viewMode;
            }

            const custodyViewSelect = document.getElementById('custodyView');
            if (custodyViewSelect) {
                custodyViewSelect.value = custodyFilter;
            }

            const rowsPerPageSelect = document.getElementById('rowsPerPage');
            if (rowsPerPageSelect) {
                rowsPerPageSelect.value = rowsPerPage;
            }

            loadInventory();
        });

        function updateChangesIndicator() {
            // For read-only users (ops), these elements don't exist
            const indicator = document.getElementById('changesIndicator');
            const commitBtn = document.getElementById('commitBtn');
            const discardBtn = document.getElementById('discardBtn');

            // Exit early if elements don't exist (read-only mode)
            if (!indicator || !commitBtn || !discardBtn) {
                return;
            }

            const totalChanges = Object.keys(pendingChanges.modified).length +
                                 pendingChanges.added.length +
                                 pendingChanges.deleted.length;

            if (totalChanges > 0) {
                indicator.textContent = `${totalChanges} pending change${totalChanges > 1 ? 's' : ''}`;
                indicator.classList.remove('no-changes');
                commitBtn.disabled = false;
                discardBtn.disabled = false;
            } else {
                indicator.textContent = 'No pending changes';
                indicator.classList.add('no-changes');
                commitBtn.disabled = true;
                discardBtn.disabled = true;
            }
        }

        function trackModification(rowIndex, field, newValue) {
            if (!pendingChanges.modified[rowIndex]) {
                pendingChanges.modified[rowIndex] = {};
            }
            pendingChanges.modified[rowIndex][field] = newValue;
            updateChangesIndicator();
        }

        function trackAddition(rowData) {
            pendingChanges.added.push(rowData);
            updateChangesIndicator();
        }

        function trackDeletion(rowIndex) {
            // Remove from modified if it was modified
            delete pendingChanges.modified[rowIndex];

            // Check if it's a newly added row (negative index)
            if (rowIndex < 0) {
                // Remove from added array
                pendingChanges.added = pendingChanges.added.filter(r => r._row_index !== rowIndex);
            } else {
                // Add to deleted array
                if (!pendingChanges.deleted.includes(rowIndex)) {
                    pendingChanges.deleted.push(rowIndex);
                }
            }
            updateChangesIndicator();
        }

        async function loadInventory() {
            try {
                console.log('Loading inventory data...');
                const response = await fetch('/api/inventory/get');
                console.log('Response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Data received:', data);

                if (data.error) {
                    console.error('API returned error:', data.error);
                    showAlert('Error loading inventory: ' + data.error, 'error');
                    return;
                }

                headers = data.headers;
                inventoryData = data.data;
                console.log(`Loaded ${inventoryData.length} items with ${headers.length} headers`);

                // Detect column data types
                detectAllColumnTypes();

                // Reset pending changes
                pendingChanges = {
                    modified: {},
                    added: [],
                    deleted: []
                };
                updateChangesIndicator();

                renderTable();
                console.log('Inventory loaded and rendered successfully');
            } catch (error) {
                console.error('Error:', error);
                showAlert('Failed to load inventory data', 'error');
            }
        }

        // Wildcard matching function
        // * = any characters (any length)
        // @ = any non-numeric character
        // # = any numeric character
        function matchesWildcard(text, pattern) {
            // Escape special regex characters except our wildcards
            let regexPattern = pattern
                .replace(/[.+?^${}()|[\]\\]/g, '\\$&')  // Escape special chars
                .replace(/\*/g, '.*')                    // * -> match any characters
                .replace(/@/g, '[^0-9]')                 // @ -> match non-numeric
                .replace(/#/g, '[0-9]');                 // # -> match numeric

            const regex = new RegExp('^' + regexPattern + '$', 'i');
            return regex.test(text);
        }

        function applyFilters(rows) {
            return rows.filter(row => {
                // Apply custody filter first
                if (custodyFilter !== 'all') {
                    const isCustody = (row['IsCustody'] || '').toString().toLowerCase();
                    // Handle both 'Yes'/'No' and 'True'/'False' formats
                    const isInCustody = isCustody === 'yes' || isCustody === 'true';
                    const wantInCustody = custodyFilter === 'true';
                    if (isInCustody !== wantInCustody) {
                        return false;
                    }
                }

                // Apply column filters with wildcard support
                return headers.every((header, headerIdx) => {
                    const filterValue = (columnFilters[header] || '');
                    if (!filterValue) return true;

                    // Special handling for serial column in summarized view
                    const isSerialColumn = headerIdx === serialColumnIndex;
                    if (isSerialColumn && row._is_summarized && row._serials) {
                        // Check if filter matches any serial in the range
                        return row._serials.some(serial => {
                            const serialStr = serial.toString().toLowerCase();
                            const filter = filterValue.toLowerCase();

                            // Check if filter contains wildcards
                            if (filterValue.includes('*') || filterValue.includes('@') || filterValue.includes('#')) {
                                return matchesWildcard(serialStr, filterValue);
                            } else {
                                // Regular case-insensitive substring match
                                return serialStr.includes(filter);
                            }
                        });
                    }

                    const cellValue = (row[header] || '').toString();

                    // Check if filter contains wildcards
                    if (filterValue.includes('*') || filterValue.includes('@') || filterValue.includes('#')) {
                        return matchesWildcard(cellValue, filterValue);
                    } else {
                        // Regular case-insensitive substring match
                        return cellValue.toLowerCase().includes(filterValue.toLowerCase());
                    }
                });
            });
        }

        function applySorting(rows) {
            if (advancedSortLevels.length > 0) {
                return rows.sort((a, b) => {
                    for (const level of advancedSortLevels) {
                        const aVal = a[level.column] || '';
                        const bVal = b[level.column] || '';
                        const dataType = columnTypes[level.column] || 'string';

                        const comparison = compareValues(aVal, bVal, dataType, level.direction);
                        if (comparison !== 0) {
                            return comparison;
                        }
                    }
                    return 0;
                });
            } else if (sortConfig.column) {
                return rows.sort((a, b) => {
                    const aVal = a[sortConfig.column] || '';
                    const bVal = b[sortConfig.column] || '';
                    const dataType = columnTypes[sortConfig.column] || 'string';

                    return compareValues(aVal, bVal, dataType, sortConfig.direction);
                });
            }
            return rows;
        }

        function updatePaginationInfo(totalRows, displayedRows, totalUnderlyingRows, filteredUnderlyingRows) {
            const info = document.getElementById('paginationInfo');
            const rowCountInfo = document.getElementById('rowCountInfo');
            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');
            const pageNavigation = document.getElementById('pageNavigation');
            const pageInput = document.getElementById('pageInput');
            const totalPagesSpan = document.getElementById('totalPages');

            // Update row count label - always show underlying row count
            if (filteredUnderlyingRows !== undefined && filteredUnderlyingRows < totalUnderlyingRows) {
                rowCountInfo.textContent = `Total Inventory: ${filteredUnderlyingRows} of ${totalUnderlyingRows}`;
            } else {
                rowCountInfo.textContent = `Total Inventory: ${totalUnderlyingRows}`;
            }

            if (rowsPerPage === 'all') {
                info.textContent = `Showing all ${totalRows} records`;
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                pageNavigation.style.display = 'none';
            } else {
                const start = (currentPage - 1) * parseInt(rowsPerPage) + 1;
                const end = Math.min(currentPage * parseInt(rowsPerPage), totalRows);
                info.textContent = `Showing ${start}-${end} of ${totalRows} records`;

                prevBtn.disabled = currentPage === 1;
                const totalPages = Math.ceil(totalRows / parseInt(rowsPerPage));
                nextBtn.disabled = currentPage >= totalPages;

                // Update page navigation
                pageNavigation.style.display = 'inline-flex';
                pageInput.value = currentPage;
                pageInput.max = totalPages;
                totalPagesSpan.textContent = totalPages;
            }
        }

        function renderTable() {
            const thead = document.getElementById('tableHead');
            const tbody = document.getElementById('tableBody');

            // Render headers with sort indicators and filters
            let headerRow = '<tr>';
            headers.forEach(header => {
                const sortIndicator = sortConfig.column === header
                    ? `<span class="sort-indicator">${sortConfig.direction === 'asc' ? '▲' : '▼'}</span>`
                    : '<span class="sort-indicator">⇅</span>';
                headerRow += `<th class="sortable-header" onclick="toggleSort('${header}')">${header}${sortIndicator}</th>`;
            });
            headerRow += '<th>Actions</th></tr>';

            // Filter row
            let filterRow = '<tr class="filter-row">';
            headers.forEach(header => {
                filterRow += `<td><input type="text" name="table-filter-${header}" placeholder="Filter..." value="${columnFilters[header] || ''}" onchange="updateFilter('${header}', this.value)" autocomplete="off"></td>`;
            });
            filterRow += '<td></td></tr>';

            thead.innerHTML = headerRow + filterRow;

            // Combine original data with added rows
            let allRows = [...inventoryData, ...pendingChanges.added];

            // Apply pending modifications for display (without committing)
            allRows = allRows.map(row => {
                const rowIndex = row._row_index;
                if (pendingChanges.modified[rowIndex]) {
                    // Create a new row object with modifications applied
                    return { ...row, ...pendingChanges.modified[rowIndex] };
                }
                return row;
            });

            // Track total underlying rows before summarization
            const totalUnderlyingRows = allRows.length;

            // Apply summarization if in summarized view mode
            if (viewMode === 'summarized') {
                allRows = summarizeData(allRows);
            }

            // Apply filters
            allRows = applyFilters(allRows);

            // Apply sorting
            allRows = applySorting(allRows);

            // Calculate filtered underlying row count
            let filteredUnderlyingRows;
            if (viewMode === 'summarized') {
                // Sum up all underlying rows from filtered summarized rows
                filteredUnderlyingRows = allRows.reduce((sum, row) => {
                    return sum + (row._underlying_rows ? row._underlying_rows.length : 1);
                }, 0);
            } else {
                filteredUnderlyingRows = allRows.length;
            }

            const totalRows = allRows.length;

            // Apply pagination
            let displayRows = allRows;
            if (rowsPerPage !== 'all') {
                const start = (currentPage - 1) * parseInt(rowsPerPage);
                const end = start + parseInt(rowsPerPage);
                displayRows = allRows.slice(start, end);
            }

            // Update pagination info
            updatePaginationInfo(totalRows, displayRows.length, totalUnderlyingRows, filteredUnderlyingRows);

            // Render data rows
            tbody.innerHTML = '';
            displayRows.forEach((row) => {
                const rowIndex = row._row_index;
                const isSummarized = row._is_summarized || false;
                const isDeleted = !isSummarized && pendingChanges.deleted.includes(rowIndex);

                // Check if modified: either the row itself or any underlying rows (for summarized)
                let isModified = false;
                if (!isSummarized) {
                    isModified = !!pendingChanges.modified[rowIndex];
                } else if (row._underlying_rows) {
                    // Check if any underlying row has modifications
                    isModified = row._underlying_rows.some(underlyingIdx => !!pendingChanges.modified[underlyingIdx]);
                }

                const isAdded = !isSummarized && rowIndex < 0 && rowIndex > -1000;

                const tr = document.createElement('tr');
                tr.setAttribute('data-row-index', rowIndex);
                if (isSummarized) {
                    tr.setAttribute('data-is-summarized', 'true');
                    tr.setAttribute('data-underlying-rows', JSON.stringify(row._underlying_rows || []));
                }

                // Add visual indicators for pending changes
                if (isDeleted) {
                    tr.className = 'deleted-row';
                } else if (isAdded) {
                    tr.className = 'added-row';
                } else if (isModified) {
                    tr.className = 'modified-row';
                }

                headers.forEach((header, headerIdx) => {
                    const td = document.createElement('td');
                    const isSerialColumn = headerIdx === serialColumnIndex;

                    // Make summarized rows editable except for serial column, and only if not read-only
                    const canEdit = !isReadOnly && !isDeleted && (!isSummarized || !isSerialColumn);
                    td.className = canEdit ? 'editable' : '';
                    td.setAttribute('data-field', header);

                    // Display value (modifications already applied to row data)
                    let displayValue = row[header] || '';
                    td.textContent = displayValue;

                    // Add edit capability
                    if (canEdit) {
                        td.addEventListener('click', isSummarized ? makeEditableSummarized : makeEditable);
                    }
                    tr.appendChild(td);
                });

                // Actions cell
                const actionsTd = document.createElement('td');
                actionsTd.className = 'actions-cell';
                if (isSummarized) {
                    // Show count of underlying rows
                    const count = row._underlying_rows ? row._underlying_rows.length : 0;
                    actionsTd.innerHTML = `<span style="color: #666; font-size: 12px;">${count} row${count !== 1 ? 's' : ''}</span>`;
                } else if (isReadOnly) {
                    // No actions for read-only users
                    actionsTd.innerHTML = `<span style="color: #999; font-size: 12px;">-</span>`;
                } else if (isDeleted) {
                    actionsTd.innerHTML = `
                        <button class="btn-small btn-warning" style="padding: 2px 8px;" onclick="undeleteRow(${rowIndex})">Undo Delete</button>
                    `;
                } else {
                    actionsTd.innerHTML = `
                        <button class="btn-small btn-danger" style="padding: 2px 8px;" onclick="deleteRow(${rowIndex})">Delete</button>
                    `;
                }
                tr.appendChild(actionsTd);

                tbody.appendChild(tr);
            });
        }

        function toggleSort(column) {
            if (sortConfig.column === column) {
                if (sortConfig.direction === 'asc') {
                    sortConfig.direction = 'desc';
                } else {
                    sortConfig.column = null;
                    sortConfig.direction = null;
                }
            } else {
                sortConfig.column = column;
                sortConfig.direction = 'asc';
            }
            advancedSortLevels = []; // Clear advanced sort when using column headers
            renderTable();
        }

        function updateFilter(column, value) {
            columnFilters[column] = value;
            currentPage = 1; // Reset to first page when filtering
            renderTable();
            saveFiltersToServer();
        }

        function saveFiltersToServer() {
            fetch('/api/settings/inventory', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ columnFilters: columnFilters })
            }).catch(err => console.error('Error saving filters:', err));
        }

        function clearFilters() {
            columnFilters = {};
            currentPage = 1;
            renderTable();
            saveFiltersToServer();
        }

        function exportToExcel() {
            // Get filtered data
            let allRows = [...inventoryData, ...pendingChanges.added];
            allRows = allRows.map(row => {
                const rowIndex = row._row_index;
                if (pendingChanges.modified[rowIndex]) {
                    return { ...row, ...pendingChanges.modified[rowIndex] };
                }
                return row;
            });

            // Apply summarization if in summarized view mode
            if (viewMode === 'summarized') {
                allRows = summarizeData(allRows);
            }

            const filteredData = applyFilters(allRows);

            if (filteredData.length === 0) {
                showAlert('No data to export', 'warning');
                return;
            }

            // Get visible headers (exclude internal fields)
            const exportHeaders = headers.filter(h => !h.startsWith('_'));

            // For summarized view, add a Count column
            const finalHeaders = viewMode === 'summarized'
                ? [...exportHeaders, 'Count']
                : exportHeaders;

            // Create CSV content
            const escapeCSV = (value) => {
                if (value === null || value === undefined) return '';
                const str = String(value);
                if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };

            let csv = finalHeaders.map(escapeCSV).join(',') + '\n';

            filteredData.forEach(row => {
                const rowData = exportHeaders.map(header => escapeCSV(row[header]));
                // Add count for summarized view
                if (viewMode === 'summarized') {
                    const count = row._underlying_rows ? row._underlying_rows.length : 1;
                    rowData.push(count);
                }
                csv += rowData.join(',') + '\n';
            });

            // Create and download file
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            const timestamp = new Date().toISOString().slice(0, 10);
            const viewSuffix = viewMode === 'summarized' ? '_summarized' : '';
            link.setAttribute('download', `inventory_export${viewSuffix}_${timestamp}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            showAlert(`Exported ${filteredData.length} records to Excel`, 'success');
        }

        function changeRowsPerPage() {
            const select = document.getElementById('rowsPerPage');
            rowsPerPage = select.value;
            currentPage = 1;
            renderTable();
        }

        function changePage(delta) {
            currentPage += delta;
            renderTable();
        }

        function goToPage() {
            const pageInput = document.getElementById('pageInput');
            const targetPage = parseInt(pageInput.value);

            if (isNaN(targetPage) || targetPage < 1) {
                showAlert('Please enter a valid page number', 'warning');
                return;
            }

            // Get total pages
            const filteredData = applyFilters(inventoryData);
            const totalPages = Math.ceil(filteredData.length / parseInt(rowsPerPage));

            if (targetPage > totalPages) {
                showAlert(`Page ${targetPage} does not exist. Maximum page is ${totalPages}`, 'warning');
                pageInput.value = currentPage;
                return;
            }

            currentPage = targetPage;
            renderTable();
        }

        function handlePageInputEnter(event) {
            if (event.key === 'Enter') {
                goToPage();
            }
        }

        function isValidDateFormat(value) {
            if (!value || value.trim() === '') return true; // Allow empty values
            const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
            if (!dateRegex.test(value)) return false;
            // Also check if it's a valid date
            const date = new Date(value);
            return !isNaN(date.getTime());
        }

        function makeEditable(event) {
            const cell = event.target;

            // If already editing, don't do anything
            if (cell.querySelector('input')) {
                return;
            }

            const originalValue = cell.textContent;
            const field = cell.getAttribute('data-field');
            const row = cell.parentElement;
            const rowIndex = parseInt(row.getAttribute('data-row-index'));
            const isDate = columnTypes[field] === 'date';

            // Create input element
            const input = document.createElement('input');
            input.type = isDate ? 'date' : 'text';
            input.value = originalValue;
            input.className = 'editing';
            input.style.width = '100%';
            input.style.border = 'none';
            input.style.padding = '5px';

            // Replace cell content with input
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();

            // Handle blur (save)
            input.addEventListener('blur', function() {
                const newValue = input.value;

                // Validate date format if it's a date column
                if (isDate && newValue && !isValidDateFormat(newValue)) {
                    showAlert('Invalid date format. Please use YYYY-MM-DD format.', 'error');
                    cell.textContent = originalValue;
                    return;
                }

                cell.textContent = newValue;

                // Track change if value changed
                if (newValue !== originalValue) {
                    trackModification(rowIndex, field, newValue);
                    renderTable(); // Re-render to show modified row styling
                }
            });

            // Handle Enter key
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }

        function makeEditableSummarized(event) {
            const cell = event.target;

            // If already editing, don't do anything
            if (cell.querySelector('input')) {
                return;
            }

            const originalValue = cell.textContent;
            const field = cell.getAttribute('data-field');
            const row = cell.parentElement;
            const underlyingRowsStr = row.getAttribute('data-underlying-rows');
            const underlyingRows = JSON.parse(underlyingRowsStr || '[]');
            const isDate = columnTypes[field] === 'date';

            // Create input element
            const input = document.createElement('input');
            input.type = isDate ? 'date' : 'text';
            input.value = originalValue;
            input.className = 'editing';
            input.style.width = '100%';
            input.style.border = 'none';
            input.style.padding = '5px';
            input.style.backgroundColor = '#fff3cd'; // Yellow to indicate it affects multiple rows

            // Replace cell content with input
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();

            // Handle blur (save)
            input.addEventListener('blur', function() {
                const newValue = input.value;

                // Validate date format if it's a date column
                if (isDate && newValue && !isValidDateFormat(newValue)) {
                    showAlert('Invalid date format. Please use YYYY-MM-DD format.', 'error');
                    cell.textContent = originalValue;
                    return;
                }

                cell.textContent = newValue;

                // Track change for ALL underlying rows if value changed
                if (newValue !== originalValue) {
                    underlyingRows.forEach(rowIdx => {
                        trackModification(rowIdx, field, newValue);
                    });
                    renderTable(); // Re-render to show modified row styling
                }
            });

            // Handle Enter key
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }

        let rowToDelete = null;

        function deleteRow(rowIndex) {
            if (isReadOnly) {
                showAlert('You do not have permission to delete items. Your role is read-only.', 'warning');
                return;
            }

            // Store the row index for later
            rowToDelete = rowIndex;

            // Find the row data
            const row = inventoryData.find(r => r._row_index === rowIndex);
            if (!row) return;

            // Populate the modal with item info
            const infoDiv = document.getElementById('deleteRowInfo');
            const serialColumn = headers[serialColumnIndex];
            const serial = row[serialColumn] || 'N/A';

            infoDiv.innerHTML = `
                <strong>Serial:</strong> ${serial}<br>
                ${headers.slice(0, 5).map(h => `<strong>${h}:</strong> ${row[h] || ''}`).join('<br>')}
            `;

            // Clear password field
            document.getElementById('deleteRowPassword').value = '';

            // Show modal
            const modal = document.getElementById('deleteRowModal');
            modal.style.display = 'flex';
        }

        function closeDeleteRowModal() {
            const modal = document.getElementById('deleteRowModal');
            modal.style.display = 'none';
            rowToDelete = null;
        }

        async function confirmDeleteRow() {
            const password = document.getElementById('deleteRowPassword').value;

            if (!password) {
                showAlert('Please enter your password', 'warning');
                return;
            }

            if (rowToDelete === null) {
                showAlert('No row selected for deletion', 'error');
                return;
            }

            try {
                // Verify password with backend
                const response = await fetch('/api/verify-password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password: password })
                });

                const result = await response.json();

                if (result.success) {
                    // Password verified, proceed with deletion
                    trackDeletion(rowToDelete);
                    renderTable();
                    closeDeleteRowModal();
                    showAlert('Item marked for deletion. Click "Save Changes" to commit.', 'success');
                } else {
                    showAlert('Incorrect password', 'error');
                }
            } catch (error) {
                console.error('Error verifying password:', error);
                showAlert('Failed to verify password', 'error');
            }
        }

        function undeleteRow(rowIndex) {
            if (isReadOnly) {
                showAlert('You do not have permission to modify items. Your role is read-only.', 'warning');
                return;
            }
            // Remove from deleted array
            pendingChanges.deleted = pendingChanges.deleted.filter(idx => idx !== rowIndex);
            updateChangesIndicator();
            renderTable();
        }

        function addNewRow() {
            // Check if user has write access
            if (isReadOnly) {
                showAlert('You do not have permission to add items. Your role is read-only.', 'warning');
                return;
            }

            const modal = document.getElementById('addItemModal');
            const formDiv = document.getElementById('addItemForm');

            // Reset to single mode
            document.querySelector('input[name="entryMode"][value="single"]').checked = true;

            // Populate form fields dynamically based on headers
            formDiv.innerHTML = '';

            headers.forEach((header, headerIdx) => {
                const formGroup = document.createElement('div');
                formGroup.className = 'form-group';
                formGroup.style.marginBottom = '15px';

                const label = document.createElement('label');
                label.textContent = header;
                label.style.display = 'block';
                label.style.marginBottom = '5px';
                label.style.fontWeight = '600';
                label.style.color = '#333';

                const input = document.createElement('input');
                input.type = 'text';
                input.id = `addItem_${header}`;
                input.name = header;
                input.placeholder = `Enter ${header}`;
                input.style.width = '100%';
                input.style.padding = '8px 12px';
                input.style.border = '2px solid #e0e0e0';
                input.style.borderRadius = '5px';
                input.style.fontSize = '14px';

                // Create datalist with unique values for non-serial columns
                const isSerialColumn = headerIdx === serialColumnIndex;
                if (!isSerialColumn && inventoryData && inventoryData.length > 0) {
                    // Get unique values for this column
                    const uniqueValues = new Set();
                    inventoryData.forEach(row => {
                        const value = row[header];
                        if (value && value.toString().trim() !== '') {
                            uniqueValues.add(value.toString().trim());
                        }
                    });

                    // Create datalist if there are unique values
                    if (uniqueValues.size > 0) {
                        const datalistId = `datalist_${header}`;
                        const datalist = document.createElement('datalist');
                        datalist.id = datalistId;

                        // Sort values alphabetically
                        const sortedValues = Array.from(uniqueValues).sort();

                        // Add options to datalist
                        sortedValues.forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            datalist.appendChild(option);
                        });

                        // Link input to datalist
                        input.setAttribute('list', datalistId);
                        formGroup.appendChild(datalist);
                    }
                }

                formGroup.appendChild(label);
                formGroup.appendChild(input);
                formDiv.appendChild(formGroup);
            });

            // Show modal
            modal.style.display = 'flex';

            // Focus first input
            const firstInput = formDiv.querySelector('input');
            if (firstInput) {
                setTimeout(() => firstInput.focus(), 100);
            }
        }

        function closeAddItemModal() {
            const modal = document.getElementById('addItemModal');
            const formDiv = document.getElementById('addItemForm');

            // Close modal
            modal.style.display = 'none';

            // Clear form
            formDiv.innerHTML = '';

            // Reset to single mode
            document.querySelector('input[name="entryMode"][value="single"]').checked = true;
        }

        function toggleEntryMode() {
            const selectedMode = document.querySelector('input[name="entryMode"]:checked').value;
            const formDiv = document.getElementById('addItemForm');

            if (selectedMode === 'group') {
                // In group mode, we need to show serial range inputs
                // Find the serial column field and modify it to show "From" and "To"
                const serialColumn = headers[serialColumnIndex];
                const serialInput = formDiv.querySelector(`#addItem_${serialColumn}`);

                if (serialInput) {
                    const formGroup = serialInput.parentElement;

                    // Clear and rebuild the serial input as two fields
                    formGroup.innerHTML = '';

                    const label = document.createElement('label');
                    label.textContent = `${serialColumn} Range`;
                    label.style.display = 'block';
                    label.style.marginBottom = '5px';
                    label.style.fontWeight = '600';
                    label.style.color = '#333';
                    formGroup.appendChild(label);

                    // Create "From" field
                    const fromDiv = document.createElement('div');
                    fromDiv.style.marginBottom = '8px';

                    const fromLabel = document.createElement('label');
                    fromLabel.textContent = 'From:';
                    fromLabel.style.display = 'block';
                    fromLabel.style.fontSize = '13px';
                    fromLabel.style.color = '#666';
                    fromLabel.style.marginBottom = '3px';

                    const fromInput = document.createElement('input');
                    fromInput.type = 'text';
                    fromInput.id = `addItem_${serialColumn}_from`;
                    fromInput.placeholder = 'e.g., AB133311';
                    fromInput.style.width = '100%';
                    fromInput.style.padding = '8px 12px';
                    fromInput.style.border = '2px solid #e0e0e0';
                    fromInput.style.borderRadius = '5px';
                    fromInput.style.fontSize = '14px';

                    fromDiv.appendChild(fromLabel);
                    fromDiv.appendChild(fromInput);
                    formGroup.appendChild(fromDiv);

                    // Create "To" field
                    const toDiv = document.createElement('div');

                    const toLabel = document.createElement('label');
                    toLabel.textContent = 'To:';
                    toLabel.style.display = 'block';
                    toLabel.style.fontSize = '13px';
                    toLabel.style.color = '#666';
                    toLabel.style.marginBottom = '3px';

                    const toInput = document.createElement('input');
                    toInput.type = 'text';
                    toInput.id = `addItem_${serialColumn}_to`;
                    toInput.placeholder = 'e.g., AB133320';
                    toInput.style.width = '100%';
                    toInput.style.padding = '8px 12px';
                    toInput.style.border = '2px solid #e0e0e0';
                    toInput.style.borderRadius = '5px';
                    toInput.style.fontSize = '14px';

                    toDiv.appendChild(toLabel);
                    toDiv.appendChild(toInput);
                    formGroup.appendChild(toDiv);
                }
            } else {
                // In single mode, restore to single serial input
                addNewRow(); // Re-populate form
            }
        }

        function submitAddItem() {
            const selectedMode = document.querySelector('input[name="entryMode"]:checked').value;

            if (selectedMode === 'single') {
                // Single item mode - create one row
                const newRowData = {};

                headers.forEach(header => {
                    const input = document.getElementById(`addItem_${header}`);
                    newRowData[header] = input ? input.value.trim() : '';
                });

                // Assign temporary ID
                newRowData._row_index = nextTempId--;

                // Track addition
                trackAddition(newRowData);

                // Close modal and refresh table
                closeAddItemModal();
                renderTable();

                showAlert('Item added successfully!', 'success');
            } else {
                // Group mode - create multiple rows based on serial range
                const serialColumn = headers[serialColumnIndex];
                const fromInput = document.getElementById(`addItem_${serialColumn}_from`);
                const toInput = document.getElementById(`addItem_${serialColumn}_to`);

                if (!fromInput || !toInput) {
                    showAlert('Error: Serial range inputs not found', 'error');
                    return;
                }

                const fromSerial = fromInput.value.trim();
                const toSerial = toInput.value.trim();

                if (!fromSerial || !toSerial) {
                    showAlert('Please enter both "From" and "To" serial numbers', 'warning');
                    return;
                }

                // Parse the serials
                const parsedFrom = parseSerial(fromSerial);
                const parsedTo = parseSerial(toSerial);

                if (!parsedFrom || !parsedTo || parsedFrom.number === null || parsedTo.number === null) {
                    showAlert('Invalid serial format. Serials must end with numbers (e.g., AB133311)', 'error');
                    return;
                }

                if (parsedFrom.number > parsedTo.number) {
                    showAlert('"From" serial ending number must be less than or equal to "To" serial ending number', 'error');
                    return;
                }

                // Collect common field values
                const commonData = {};
                headers.forEach(header => {
                    if (header !== serialColumn) {
                        const input = document.getElementById(`addItem_${header}`);
                        commonData[header] = input ? input.value.trim() : '';
                    }
                });

                // Generate rows for the range using the "From" prefix
                const itemsToAdd = [];
                for (let num = parsedFrom.number; num <= parsedTo.number; num++) {
                    const newRowData = { ...commonData };

                    // Format serial number using the "From" serial's prefix
                    const serial = parsedFrom.prefix + num;
                    newRowData[serialColumn] = serial;

                    // Assign temporary ID
                    newRowData._row_index = nextTempId--;

                    itemsToAdd.push(newRowData);
                }

                // Add all items
                itemsToAdd.forEach(item => trackAddition(item));

                // Close modal and refresh table
                closeAddItemModal();
                renderTable();

                showAlert(`${itemsToAdd.length} items added successfully!`, 'success');
            }
        }

        function discardChanges() {
            if (isReadOnly) {
                showAlert('You do not have permission to modify items. Your role is read-only.', 'warning');
                return;
            }
            showConfirm('Are you sure you want to discard all pending changes?', function() {
                pendingChanges = {
                    modified: {},
                    added: [],
                    deleted: []
                };
                updateChangesIndicator();
                renderTable();
            });
        }

        function showCommitSummary() {
            const modal = document.getElementById('commitModal');
            const summaryDiv = document.getElementById('changeSummary');

            summaryDiv.innerHTML = '';

            // Show modified items
            for (const [rowIndex, changes] of Object.entries(pendingChanges.modified)) {
                const originalRow = inventoryData.find(r => r._row_index == rowIndex);
                const itemId = getItemIdentifier(originalRow);

                const itemDiv = document.createElement('div');
                itemDiv.className = 'summary-item modified';

                const changedFields = Object.entries(changes).map(([field, newValue]) => {
                    const oldValue = originalRow ? originalRow[field] : '';
                    return `<strong>${field}:</strong> "${oldValue}" → "${newValue}"`;
                }).join('<br>');

                itemDiv.innerHTML = `
                    <div class="summary-item-title">Modified: ${itemId}</div>
                    <div class="summary-item-details">${changedFields}</div>
                `;
                summaryDiv.appendChild(itemDiv);
            }

            // Show added items
            pendingChanges.added.forEach(row => {
                const itemId = getItemIdentifier(row);
                const itemDiv = document.createElement('div');
                itemDiv.className = 'summary-item added';

                const fields = headers.map(h => `<strong>${h}:</strong> "${row[h] || ''}"`).join('<br>');

                itemDiv.innerHTML = `
                    <div class="summary-item-title">Added: ${itemId}</div>
                    <div class="summary-item-details">${fields}</div>
                `;
                summaryDiv.appendChild(itemDiv);
            });

            // Show deleted items
            pendingChanges.deleted.forEach(rowIndex => {
                const originalRow = inventoryData.find(r => r._row_index === rowIndex);
                const itemId = getItemIdentifier(originalRow);

                const itemDiv = document.createElement('div');
                itemDiv.className = 'summary-item deleted';

                itemDiv.innerHTML = `
                    <div class="summary-item-title">Deleted: ${itemId}</div>
                    <div class="summary-item-details">This item will be removed from the inventory</div>
                `;
                summaryDiv.appendChild(itemDiv);
            });

            modal.style.display = 'flex';
        }

        function closeCommitModal() {
            const modal = document.getElementById('commitModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function getItemIdentifier(row) {
            // Use first column value as identifier, or 'Unknown' if not available
            if (!row || !headers || headers.length === 0) return 'Unknown';
            const firstCol = headers[0];
            return row[firstCol] || 'Unknown';
        }

        function buildChangeSummary() {
            const summary = {
                modified: [],
                added: [],
                deleted: []
            };

            // Build modified summary
            for (const [rowIndex, changes] of Object.entries(pendingChanges.modified)) {
                const originalRow = inventoryData.find(r => r._row_index == rowIndex);
                const itemId = getItemIdentifier(originalRow);
                // Get Serial from original row
                const serial = originalRow ? (originalRow['Serial'] || originalRow['serial'] || '') : '';

                const changeDetails = {};
                for (const [field, newValue] of Object.entries(changes)) {
                    const oldValue = originalRow ? originalRow[field] : '';
                    changeDetails[field] = { old: oldValue, new: newValue };
                }

                summary.modified.push({
                    itemId: itemId,
                    Serial: serial,
                    changes: changeDetails
                });
            }

            // Build added summary
            pendingChanges.added.forEach(row => {
                const itemData = {};
                headers.forEach(h => {
                    itemData[h] = row[h] || '';
                });
                summary.added.push(itemData);
            });

            // Build deleted summary
            pendingChanges.deleted.forEach(rowIndex => {
                const originalRow = inventoryData.find(r => r._row_index === rowIndex);
                const itemId = getItemIdentifier(originalRow);
                // Get Serial from original row
                const serial = originalRow ? (originalRow['Serial'] || originalRow['serial'] || '') : '';
                const itemData = {};
                if (originalRow) {
                    headers.forEach(h => {
                        itemData[h] = originalRow[h] || '';
                    });
                }
                summary.deleted.push({
                    itemId: itemId,
                    Serial: serial,
                    data: itemData
                });
            });

            return summary;
        }

        async function commitChanges() {
            const modal = document.getElementById('commitModal');
            modal.style.display = 'none';

            // Show progress modal
            showProgress();

            try {
                const totalChanges = Object.keys(pendingChanges.modified).length +
                                    pendingChanges.added.length +
                                    pendingChanges.deleted.length;

                // Stage 1: Preparing (0-20%)
                updateProgress(5, 'Preparing changes...', `Processing ${totalChanges} change(s)...`);
                await new Promise(r => setTimeout(r, 100)); // Small delay for UI update

                // Build change summary
                const changeSummary = buildChangeSummary();
                updateProgress(10, 'Preparing changes...', 'Building change summary...');

                // Prepare modifications for batch commit
                const modifications = {};
                for (const [rowIndex, changes] of Object.entries(pendingChanges.modified)) {
                    const originalRow = inventoryData.find(r => r._row_index == rowIndex);
                    const fullRowData = { ...originalRow, ...changes };
                    delete fullRowData._row_index;
                    modifications[rowIndex] = fullRowData;
                }

                // Prepare additions
                const additions = pendingChanges.added.map(row => {
                    const rowData = { ...row };
                    delete rowData._row_index;
                    return rowData;
                });

                updateProgress(20, 'Preparing changes...', 'Changes prepared successfully');
                await new Promise(r => setTimeout(r, 100));

                // Stage 2: Sending to server (20-70%)
                updateProgress(25, 'Saving to database...', `Sending ${totalChanges} change(s) to server...`);

                const response = await fetch('/api/inventory/commit-batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        summary: changeSummary,
                        modifications: modifications,
                        additions: additions,
                        deletions: pendingChanges.deleted
                    })
                });

                updateProgress(70, 'Processing response...', 'Server processing complete');

                const result = await response.json();

                // Stage 3: Reloading data (70-95%)
                updateProgress(75, 'Reloading inventory...', 'Fetching updated data...');

                // Reload inventory
                await loadInventory();

                updateProgress(95, 'Finishing up...', 'Almost done...');
                await new Promise(r => setTimeout(r, 200));

                // Stage 4: Complete (100%)
                updateProgress(100, 'Complete!', `${totalChanges} change(s) saved successfully`);
                await new Promise(r => setTimeout(r, 500));

                hideProgress();

                if (result.error) {
                    showAlert('Error committing changes: ' + result.error, 'error');
                } else {
                    showAlert(`All changes committed successfully! (${totalChanges} operation${totalChanges > 1 ? 's' : ''})`, 'success');
                }

            } catch (error) {
                console.error('Commit error:', error);
                hideProgress();
                showAlert('Failed to commit changes', 'error');
            }
        }

        // Advanced Sort Functions
        function showAdvancedSort() {
            const modal = document.getElementById('advancedSortModal');
            renderSortLevels();
            modal.style.display = 'flex';
        }

        function closeAdvancedSort() {
            const modal = document.getElementById('advancedSortModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function renderSortLevels() {
            const container = document.getElementById('sortLevelsContainer');
            container.innerHTML = '';

            if (advancedSortLevels.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center;">No sort levels configured. Click "Add Sort Level" to begin.</p>';
                return;
            }

            advancedSortLevels.forEach((level, index) => {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'form-card';
                levelDiv.style.marginBottom = '10px';
                levelDiv.innerHTML = `
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <strong>Level ${index + 1}:</strong>
                        <select onchange="updateSortLevel(${index}, 'column', this.value)" style="flex: 1;">
                            ${headers.map(h => `<option value="${h}" ${level.column === h ? 'selected' : ''}>${h}</option>`).join('')}
                        </select>
                        <select onchange="updateSortLevel(${index}, 'direction', this.value)">
                            <option value="asc" ${level.direction === 'asc' ? 'selected' : ''}>Ascending</option>
                            <option value="desc" ${level.direction === 'desc' ? 'selected' : ''}>Descending</option>
                        </select>
                        <button class="btn-small btn-danger" onclick="removeSortLevel(${index})">Remove</button>
                    </div>
                `;
                container.appendChild(levelDiv);
            });
        }

        function addSortLevel() {
            if (headers.length === 0) return;

            advancedSortLevels.push({
                column: headers[0],
                direction: 'asc'
            });
            renderSortLevels();
        }

        function updateSortLevel(index, field, value) {
            if (advancedSortLevels[index]) {
                advancedSortLevels[index][field] = value;
            }
        }

        function removeSortLevel(index) {
            advancedSortLevels.splice(index, 1);
            renderSortLevels();
        }

        function clearSort() {
            advancedSortLevels = [];
            sortConfig.column = null;
            sortConfig.direction = null;
            renderSortLevels();
        }

        function applyAdvancedSort() {
            sortConfig.column = null;
            sortConfig.direction = null;
            closeAdvancedSort();
            renderTable();
        }

        // Backup management functions
        async function showBackups() {
            const modal = document.getElementById('backupModal');
            if (!modal) return;

            modal.style.display = 'flex';
            await loadBackups();
        }

        function closeBackupModal() {
            const modal = document.getElementById('backupModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        async function loadBackups() {
            try {
                const response = await fetch('/api/inventory/backups');
                const data = await response.json();

                const container = document.getElementById('backupGroupsContainer');
                if (!container) return;

                if (data.error) {
                    container.innerHTML = '<p style="text-align: center; color: #dc3545;">Error loading backups: ' + data.error + '</p>';
                    return;
                }

                if (!data.grouped || Object.keys(data.grouped).length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666;">No backups available yet. Backups will be created automatically when you edit the inventory.</p>';
                    return;
                }

                container.innerHTML = '';

                // Get dates and sort newest first (Object.entries may not preserve order)
                const sortedDates = Object.keys(data.grouped).sort((a, b) => {
                    // Sort by date string descending (newest first)
                    return b.localeCompare(a);
                });

                // Render each date group in sorted order
                for (const date of sortedDates) {
                    const backups = data.grouped[date];
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'backup-group';

                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'backup-group-header';
                    headerDiv.innerHTML = `
                        <h4>${date} (${backups.length} backup${backups.length > 1 ? 's' : ''})</h4>
                        <button class="btn-small btn-danger btn-icon" onclick="deleteDateGroup('${date}')">
                            Delete All from ${date}
                        </button>
                    `;
                    groupDiv.appendChild(headerDiv);

                    const bodyDiv = document.createElement('div');
                    bodyDiv.className = 'backup-group-body';

                    backups.forEach(backup => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'backup-item';

                        const hasSummary = backup.summary && (
                            (backup.summary.modified && backup.summary.modified.length > 0) ||
                            (backup.summary.added && backup.summary.added.length > 0) ||
                            (backup.summary.deleted && backup.summary.deleted.length > 0)
                        );

                        // Create info section
                        const infoDiv = document.createElement('div');
                        infoDiv.className = 'backup-info';
                        infoDiv.innerHTML = `
                            <div class="backup-time">${backup.time_only}</div>
                            <div class="backup-meta">
                                <strong>User:</strong> ${backup.username} |
                                <strong>Action:</strong> ${backup.action} |
                                <strong>Size:</strong> ${formatFileSize(backup.size)}
                            </div>
                        `;

                        // Create actions section
                        const actionsDiv = document.createElement('div');
                        actionsDiv.className = 'backup-actions';

                        // Summary button
                        if (hasSummary) {
                            const summaryBtn = document.createElement('button');
                            summaryBtn.className = 'btn-small btn-edit btn-icon';
                            summaryBtn.textContent = 'Summary';
                            summaryBtn.onclick = () => showBackupSummary(backup.summary, backup.date);
                            actionsDiv.appendChild(summaryBtn);
                        }

                        // Restore button
                        const restoreBtn = document.createElement('button');
                        restoreBtn.className = 'btn-small btn-success btn-icon';
                        restoreBtn.textContent = 'Restore';
                        restoreBtn.onclick = () => restoreBackup(backup.filename, backup.date, backup.username, backup.action);
                        actionsDiv.appendChild(restoreBtn);

                        // Delete button
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn-small btn-danger btn-icon';
                        deleteBtn.textContent = 'Delete';
                        deleteBtn.onclick = () => deleteBackup(backup.filename, backup.date);
                        actionsDiv.appendChild(deleteBtn);

                        itemDiv.appendChild(infoDiv);
                        itemDiv.appendChild(actionsDiv);
                        bodyDiv.appendChild(itemDiv);
                    });

                    groupDiv.appendChild(bodyDiv);
                    container.appendChild(groupDiv);
                }
            } catch (error) {
                console.error('Error:', error);
                const container = document.getElementById('backupGroupsContainer');
                if (container) {
                    container.innerHTML = '<p style="text-align: center; color: #dc3545;">Failed to load backups</p>';
                }
            }
        }

        async function restoreBackup(filename, date, username, action) {
            const confirmMsg = `Restore this backup?\n\n` +
                `Date: ${date}\n` +
                `User: ${username}\n` +
                `Action: ${action}\n\n` +
                `This will replace the current inventory with the backup version.`;

            showConfirm(confirmMsg, async function() {
                try {
                    const response = await fetch('/api/inventory/restore', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            filename: filename
                        })
                    });

                    const result = await response.json();

                    if (result.error) {
                        showAlert('Error restoring backup: ' + result.error, 'error');
                    } else {
                        showAlert('Backup restored successfully!', 'success');
                        closeBackupModal();
                        loadInventory(); // Reload the inventory table
                    }
                } catch (error) {
                    console.error('Error:', error);
                    showAlert('Failed to restore backup', 'error');
                }
            });
        }

        async function deleteBackup(filename, date) {
            showConfirm(`Delete this backup from ${date}?\n\nThis action cannot be undone.`, async function() {
                try {
                    const response = await fetch('/api/inventory/backup/delete', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            filename: filename
                        })
                    });

                    const result = await response.json();

                    if (result.error) {
                        showAlert('Error deleting backup: ' + result.error, 'error');
                    } else {
                        await loadBackups(); // Reload the backup list
                    }
                } catch (error) {
                    console.error('Error:', error);
                    showAlert('Failed to delete backup', 'error');
                }
            });
        }

        async function deleteDateGroup(date) {
            showConfirm(`Delete ALL backups from ${date}?\n\nThis action cannot be undone.`, async function() {
                try {
                    const response = await fetch('/api/inventory/backup/delete-date', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            date: date
                        })
                    });

                    const result = await response.json();

                    if (result.error) {
                        showAlert('Error deleting backups: ' + result.error, 'error');
                    } else {
                        showAlert(result.message, 'success');
                        await loadBackups(); // Reload the backup list
                    }
                } catch (error) {
                    console.error('Error:', error);
                    showAlert('Failed to delete backups', 'error');
                }
            });
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function showBackupSummary(summary, date) {
            const modal = document.getElementById('summaryModal');
            const title = document.getElementById('summaryModalTitle');
            const content = document.getElementById('backupSummaryContent');

            title.textContent = `Change Summary - ${date}`;
            content.innerHTML = '';

            // Helper to get Serial from item (handles different summary structures)
            function getSerialFromItem(item) {
                // Check direct Serial property first
                if (item.Serial) return item.Serial;
                if (item.serial) return item.serial;
                // Check nested data object (for deleted items in old format)
                if (item.data) {
                    if (item.data.Serial) return item.data.Serial;
                    if (item.data.serial) return item.data.serial;
                }
                // Fallback
                return 'Unknown';
            }

            // Show modified items
            if (summary.modified && summary.modified.length > 0) {
                summary.modified.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'summary-item modified';

                    const serial = getSerialFromItem(item);
                    const changedFields = Object.entries(item.changes || {}).map(([field, values]) => {
                        return `<strong>${field}:</strong> "${values.old}" → "${values.new}"`;
                    }).join('<br>');

                    itemDiv.innerHTML = `
                        <div class="summary-item-title">Modified - Serial: ${serial}</div>
                        <div class="summary-item-details">${changedFields}</div>
                    `;
                    content.appendChild(itemDiv);
                });
            }

            // Show added items
            if (summary.added && summary.added.length > 0) {
                summary.added.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'summary-item added';

                    const serial = getSerialFromItem(item);

                    // Show all fields except Serial (already in title)
                    const fields = Object.entries(item)
                        .filter(([field]) => field.toLowerCase() !== 'serial')
                        .map(([field, value]) => {
                            return `<strong>${field}:</strong> "${value}"`;
                        }).join('<br>');

                    itemDiv.innerHTML = `
                        <div class="summary-item-title">Added - Serial: ${serial}</div>
                        <div class="summary-item-details">${fields || 'No additional details'}</div>
                    `;
                    content.appendChild(itemDiv);
                });
            }

            // Show deleted items
            if (summary.deleted && summary.deleted.length > 0) {
                summary.deleted.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'summary-item deleted';

                    // Handle both old format (item.data) and new format (direct item object)
                    const itemData = item.data || item;
                    const serial = itemData.Serial || itemData.serial || item.itemId || 'Unknown';

                    const fields = Object.entries(itemData)
                        .filter(([field]) => field.toLowerCase() !== 'serial' && field !== 'itemId')
                        .map(([field, value]) => {
                            return `<strong>${field}:</strong> "${value}"`;
                        }).join('<br>');

                    itemDiv.innerHTML = `
                        <div class="summary-item-title">Deleted - Serial: ${serial}</div>
                        <div class="summary-item-details">${fields || 'No additional details'}</div>
                    `;
                    content.appendChild(itemDiv);
                });
            }

            if (content.innerHTML === '') {
                content.innerHTML = '<p style="text-align: center; color: #666;">No detailed summary available</p>';
            }

            modal.style.display = 'flex';
        }

        function closeSummaryModal() {
            const modal = document.getElementById('summaryModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const backupModal = document.getElementById('backupModal');
            const commitModal = document.getElementById('commitModal');
            const summaryModal = document.getElementById('summaryModal');
            const advancedSortModal = document.getElementById('advancedSortModal');
            const addItemModal = document.getElementById('addItemModal');

            if (backupModal && event.target === backupModal) {
                closeBackupModal();
            }
            if (commitModal && event.target === commitModal) {
                closeCommitModal();
            }
            if (summaryModal && event.target === summaryModal) {
                closeSummaryModal();
            }
            if (advancedSortModal && event.target === advancedSortModal) {
                closeAdvancedSort();
            }
            if (addItemModal && event.target === addItemModal) {
                closeAddItemModal();
            }
            const bulkDeleteModal = document.getElementById('bulkDeleteModal');
            if (bulkDeleteModal && event.target === bulkDeleteModal) {
                closeBulkDelete();
            }
            const deleteRowModal = document.getElementById('deleteRowModal');
            if (deleteRowModal && event.target === deleteRowModal) {
                closeDeleteRowModal();
            }
        }

        // Bulk Delete Functions
        let bulkDeleteSerials = [];

        function showBulkDelete() {
            const modal = document.getElementById('bulkDeleteModal');
            document.getElementById('bulkDeleteInput').value = '';
            document.getElementById('bulkDeletePreview').style.display = 'none';
            document.getElementById('confirmBulkDeleteBtn').style.display = 'none';
            bulkDeleteSerials = [];
            modal.style.display = 'flex';
        }

        function closeBulkDelete() {
            const modal = document.getElementById('bulkDeleteModal');
            modal.style.display = 'none';
            // Clear password field and hide password section
            document.getElementById('bulkDeletePassword').value = '';
            document.getElementById('bulkDeletePasswordSection').style.display = 'none';
            // Clear preview
            document.getElementById('bulkDeletePreview').style.display = 'none';
            document.getElementById('confirmBulkDeleteBtn').style.display = 'none';
        }

        function parseSerialInput(input) {
            // Parse comma-separated serials and ranges
            const parts = input.split(',').map(p => p.trim()).filter(p => p);
            const serials = [];

            parts.forEach(part => {
                if (part.includes('-')) {
                    // Range: AB133311-AB133315
                    const [start, end] = part.split('-').map(s => s.trim());
                    const range = expandSerialRange(start, end);
                    serials.push(...range);
                } else {
                    // Single serial
                    serials.push(part);
                }
            });

            return [...new Set(serials)]; // Remove duplicates
        }

        function expandSerialRange(start, end) {
            // Extract prefix and numbers from start and end
            const startMatch = start.match(/^([A-Za-z]*)(\d+)$/);
            const endMatch = end.match(/^([A-Za-z]*)(\d+)$/);

            if (!startMatch || !endMatch) {
                // Can't parse as range, return as-is
                return [start, end];
            }

            const prefix = startMatch[1];
            const startNum = parseInt(startMatch[2]);
            const endNum = parseInt(endMatch[2]);

            const serials = [];
            for (let num = startNum; num <= endNum; num++) {
                serials.push(prefix + num);
            }

            return serials;
        }

        function previewBulkDelete() {
            const input = document.getElementById('bulkDeleteInput').value.trim();

            if (!input) {
                showAlert('Please enter serial numbers or ranges', 'warning');
                return;
            }

            // Parse the input
            const requestedSerials = parseSerialInput(input);

            // Find which serials actually exist in the database
            const existingSerials = inventoryData
                .map(item => item.Serial)
                .filter(s => s);

            const serialsToDelete = requestedSerials.filter(s => existingSerials.includes(s));
            const notFound = requestedSerials.filter(s => !existingSerials.includes(s));

            // Store for later
            bulkDeleteSerials = serialsToDelete;

            // Show preview
            const previewDiv = document.getElementById('bulkDeletePreview');
            const countP = document.getElementById('bulkDeleteCount');
            const listDiv = document.getElementById('bulkDeleteList');

            if (serialsToDelete.length === 0) {
                countP.textContent = 'No matching serials found in database';
                countP.style.color = '#856404';
                listDiv.innerHTML = notFound.length > 0
                    ? '<div style="color: #856404;">Not found: ' + notFound.join(', ') + '</div>'
                    : '';
                document.getElementById('confirmBulkDeleteBtn').style.display = 'none';
            } else {
                countP.textContent = `${serialsToDelete.length} item(s) will be deleted`;
                countP.style.color = '#dc3545';

                let html = '<div style="color: #28a745; margin-bottom: 10px;">Found (' + serialsToDelete.length + '):</div>';
                html += '<div style="color: #333;">' + serialsToDelete.join(', ') + '</div>';

                if (notFound.length > 0) {
                    html += '<div style="color: #856404; margin-top: 10px;">Not found (' + notFound.length + '):</div>';
                    html += '<div style="color: #856404;">' + notFound.join(', ') + '</div>';
                }

                listDiv.innerHTML = html;
                document.getElementById('confirmBulkDeleteBtn').style.display = 'inline-block';
                document.getElementById('bulkDeletePasswordSection').style.display = 'block';
            }

            previewDiv.style.display = 'block';
        }

        async function confirmBulkDelete() {
            if (bulkDeleteSerials.length === 0) {
                showAlert('No items to delete', 'warning');
                return;
            }

            // Get password from input
            const password = document.getElementById('bulkDeletePassword').value;
            if (!password) {
                showAlert('Please enter your password to confirm deletion', 'warning');
                return;
            }

            // Validate password first
            try {
                const passwordResponse = await fetch('/api/auth/validate-password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password: password })
                });

                const passwordResult = await passwordResponse.json();

                if (!passwordResult.valid) {
                    showAlert('Incorrect password. Please try again.', 'error');
                    return;
                }
            } catch (error) {
                console.error('Password validation error:', error);
                showAlert('Failed to validate password', 'error');
                return;
            }

            // Show confirmation dialog
            showConfirm(
                `Are you sure you want to delete ${bulkDeleteSerials.length} item(s)? This will also delete corresponding warranty records. This action cannot be undone.`,
                async () => {
                    try {
                        const response = await fetch('/api/inventory/bulk-delete', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                serials: bulkDeleteSerials
                            })
                        });

                        const result = await response.json();

                        if (result.error) {
                            showAlert('Error: ' + result.error, 'error');
                        } else {
                            showAlert(`Successfully deleted ${result.deleted_count} item(s)`, 'success');
                            closeBulkDelete();
                            await loadInventory();
                        }
                    } catch (error) {
                        console.error('Bulk delete error:', error);
                        showAlert('Failed to delete items', 'error');
                    }
                }
            );
        }

        // =====================================================================
        // CSV Import Functions (Admin Only)
        // =====================================================================

        const CSV_INVENTORY_COLUMNS = ['market', 'registry', 'product', 'project_id', 'project_type', 'protocol', 'project_name', 'vintage', 'serial', 'is_custody', 'is_assigned', 'trade_id'];
        const CSV_WARRANTY_COLUMNS = ['buy_start', 'buy_end', 'sell_start', 'sell_end', 'buy_tradeid', 'sell_tradeid', 'buy_client', 'sell_client'];
        const CSV_ALL_COLUMNS = [...CSV_INVENTORY_COLUMNS, ...CSV_WARRANTY_COLUMNS];

        // Data type definitions for validation
        const CSV_COLUMN_TYPES = {
            'is_assigned': 'integer',
            'buy_tradeid': 'integer',
            'sell_tradeid': 'integer',
            'buy_start': 'date',
            'buy_end': 'date',
            'sell_start': 'date',
            'sell_end': 'date'
        };

        function showImportCSV() {
            document.getElementById('importCSVModal').style.display = 'flex';
            document.getElementById('csvFileInput').value = '';
            document.getElementById('csvFileInfo').textContent = '';
            document.getElementById('csvValidationResult').style.display = 'none';
            document.getElementById('csvValidationResult').innerHTML = '';
            document.getElementById('importPassword').value = '';
            document.getElementById('importResultContainer').style.display = 'none';
            document.getElementById('importResultContainer').innerHTML = '';
            document.querySelector('input[name="importMode"][value="append"]').checked = true;
            updateImportModeStyle();

            // Add file input change listener with validation
            document.getElementById('csvFileInput').onchange = async function(e) {
                const file = e.target.files[0];
                const validationDiv = document.getElementById('csvValidationResult');

                if (file) {
                    const sizeKB = (file.size / 1024).toFixed(1);
                    document.getElementById('csvFileInfo').innerHTML =
                        `<span style="color: #28a745;">Selected:</span> ${file.name} (${sizeKB} KB)`;

                    // Validate CSV
                    validationDiv.style.display = 'block';
                    validationDiv.innerHTML = '<span style="color: #666;">Validating CSV...</span>';

                    try {
                        const validationResult = await validateCSVFile(file);
                        if (validationResult.valid) {
                            validationDiv.innerHTML = `
                                <div style="padding: 10px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; color: #155724;">
                                    <strong>Valid CSV</strong> - ${validationResult.rowCount} data rows found
                                    <div style="font-size: 12px; margin-top: 5px;">Columns: ${validationResult.matchedColumns.join(', ')}</div>
                                </div>
                            `;
                        } else {
                            validationDiv.innerHTML = `
                                <div style="padding: 10px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; color: #721c24;">
                                    <strong>Validation Errors:</strong>
                                    <ul style="margin: 5px 0 0 20px; padding: 0;">
                                        ${validationResult.errors.map(e => `<li>${e}</li>`).join('')}
                                    </ul>
                                </div>
                            `;
                        }
                    } catch (error) {
                        validationDiv.innerHTML = `
                            <div style="padding: 10px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; color: #721c24;">
                                <strong>Error reading file:</strong> ${error.message}
                            </div>
                        `;
                    }
                } else {
                    document.getElementById('csvFileInfo').textContent = '';
                    validationDiv.style.display = 'none';
                }
            };
        }

        function closeImportCSV() {
            document.getElementById('importCSVModal').style.display = 'none';
        }

        function downloadCSVTemplate() {
            const headers = CSV_ALL_COLUMNS.join(',');
            const exampleRow = 'VCM,Verra,VCU,VCS-123,REDD+,VM0015,Sample Forest Project,2023,SERIAL-001,Yes,0,,2024-01-01,2024-12-31,,,,,';
            const csvContent = headers + '\n' + exampleRow;

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'inventory_import_template.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function validateCSVFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        const lines = content.split(/\r?\n/).filter(line => line.trim());

                        if (lines.length === 0) {
                            resolve({ valid: false, errors: ['CSV file is empty'] });
                            return;
                        }

                        const headers = lines[0].split(',').map(h => h.trim().toLowerCase().replace(/"/g, ''));
                        const errors = [];
                        const matchedColumns = [];

                        // Check for serial column (required)
                        if (!headers.includes('serial')) {
                            errors.push('Missing required column: serial');
                        }

                        // Match columns
                        headers.forEach(h => {
                            if (CSV_ALL_COLUMNS.map(c => c.toLowerCase()).includes(h)) {
                                matchedColumns.push(h);
                            }
                        });

                        if (matchedColumns.length === 0) {
                            errors.push('No recognized columns found. Check column names.');
                        }

                        // Validate data types in rows
                        const dataRows = lines.slice(1);
                        let typeErrors = [];

                        dataRows.forEach((line, rowIndex) => {
                            if (!line.trim()) return;

                            const values = parseCSVLine(line);

                            headers.forEach((header, colIndex) => {
                                const value = values[colIndex] || '';
                                if (!value.trim()) return; // Skip empty values

                                const expectedType = CSV_COLUMN_TYPES[header];
                                if (expectedType) {
                                    const typeError = validateDataType(value, expectedType, header, rowIndex + 2);
                                    if (typeError) {
                                        typeErrors.push(typeError);
                                    }
                                }
                            });
                        });

                        // Only show first 5 type errors
                        if (typeErrors.length > 0) {
                            errors.push(...typeErrors.slice(0, 5));
                            if (typeErrors.length > 5) {
                                errors.push(`...and ${typeErrors.length - 5} more type errors`);
                            }
                        }

                        resolve({
                            valid: errors.length === 0,
                            errors: errors,
                            rowCount: dataRows.filter(r => r.trim()).length,
                            matchedColumns: matchedColumns
                        });
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        function validateDataType(value, expectedType, columnName, rowNumber) {
            value = value.replace(/"/g, '').trim();

            switch (expectedType) {
                case 'integer':
                    if (value && !/^-?\d+$/.test(value)) {
                        return `Row ${rowNumber}, ${columnName}: Expected integer, got "${value}"`;
                    }
                    break;
                case 'date':
                    if (value && !/^\d{4}-\d{2}-\d{2}$/.test(value) && !/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(value) && !/^\d{1,2}-\d{1,2}-\d{4}$/.test(value)) {
                        return `Row ${rowNumber}, ${columnName}: Expected date format (YYYY-MM-DD), got "${value}"`;
                    }
                    break;
            }
            return null;
        }

        function updateImportModeStyle() {
            const appendLabel = document.querySelector('input[name="importMode"][value="append"]').closest('label');
            const replaceLabel = document.querySelector('input[name="importMode"][value="replace"]').closest('label');
            const appendSelected = document.querySelector('input[name="importMode"][value="append"]').checked;

            if (appendSelected) {
                appendLabel.style.borderColor = '#28a745';
                appendLabel.style.background = '#d4edda';
                replaceLabel.style.borderColor = '#dee2e6';
                replaceLabel.style.background = 'white';
            } else {
                appendLabel.style.borderColor = '#dee2e6';
                appendLabel.style.background = 'white';
                replaceLabel.style.borderColor = '#dc3545';
                replaceLabel.style.background = '#f8d7da';
            }
        }

        async function executeCSVImport() {
            const fileInput = document.getElementById('csvFileInput');
            const password = document.getElementById('importPassword').value;
            const mode = document.querySelector('input[name="importMode"]:checked').value;
            const resultContainer = document.getElementById('importResultContainer');
            const importBtn = document.getElementById('importCSVBtn');

            // Validation
            if (!fileInput.files || fileInput.files.length === 0) {
                showAlert('Please select a CSV file', 'warning');
                return;
            }

            if (!password) {
                showAlert('Please enter your password to confirm the import', 'warning');
                return;
            }

            const file = fileInput.files[0];

            // Confirm for replace mode
            if (mode === 'replace') {
                const confirmed = await new Promise(resolve => {
                    showConfirm(
                        'WARNING: Replace mode will DELETE ALL existing inventory and warranty data before importing. This action cannot be undone. Are you sure you want to proceed?',
                        () => resolve(true),
                        () => resolve(false)
                    );
                });

                if (!confirmed) {
                    return;
                }
            }

            // Show loading state
            importBtn.disabled = true;
            importBtn.textContent = 'Importing...';
            resultContainer.style.display = 'block';
            resultContainer.innerHTML = '<div style="text-align: center; color: #666;"><span style="display: inline-block; width: 20px; height: 20px; border: 2px solid #007bff; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></span> Processing CSV file...</div>';

            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('password', password);
                formData.append('mode', mode);

                const response = await fetch('/api/inventory/import-csv', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.error) {
                    resultContainer.innerHTML = `
                        <div style="padding: 15px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; color: #721c24;">
                            <strong>Error:</strong> ${result.error}
                        </div>
                    `;
                } else {
                    let html = `
                        <div style="padding: 15px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; color: #155724;">
                            <strong>Import Complete!</strong><br>
                            <div style="margin-top: 10px;">
                                <span style="color: #28a745;">Imported: ${result.imported}</span> |
                                <span style="color: #856404;">Skipped: ${result.skipped}</span>
                            </div>
                        </div>
                    `;

                    if (result.errors && result.errors.length > 0) {
                        html += `
                            <div style="margin-top: 10px; padding: 15px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px;">
                                <strong style="color: #856404;">Errors (${result.total_errors}):</strong>
                                <div style="max-height: 150px; overflow-y: auto; margin-top: 8px; font-size: 12px; color: #856404;">
                                    ${result.errors.map(e => `<div>${e}</div>`).join('')}
                                    ${result.total_errors > 20 ? `<div style="font-style: italic;">...and ${result.total_errors - 20} more</div>` : ''}
                                </div>
                            </div>
                        `;
                    }

                    resultContainer.innerHTML = html;

                    // Reload inventory data
                    await loadInventory();
                    showAlert(`Successfully imported ${result.imported} record(s)`, 'success');
                }
            } catch (error) {
                console.error('Import error:', error);
                resultContainer.innerHTML = `
                    <div style="padding: 15px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; color: #721c24;">
                        <strong>Error:</strong> Failed to import CSV. Please try again.
                    </div>
                `;
            } finally {
                importBtn.disabled = false;
                importBtn.textContent = 'Import';
            }
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const importModal = document.getElementById('importCSVModal');
            if (event.target === importModal) {
                closeImportCSV();
            }
        });
    </script>
    <script>
        (function() {
            const _0x3a4b = ['QXBwbGljYXRpb24=', 'Q3JlYXRlZCBCeSBNaWtlIENoZXVuZw==', 'YXBwLWZvb3Rlcg==', 'Z2V0RWxlbWVudEJ5SWQ=', 'aW5uZXJIVE1M', 'c3R5bGU=', 'Y3NzVGV4dA=='];
            const _0x1f = window[atob('ZG9jdW1lbnQ=')];
            const _0x2e = _0x1f[atob(_0x3a4b[3])](atob(_0x3a4b[2]));
            if (_0x2e) {
                _0x2e[atob(_0x3a4b[4])] = atob(_0x3a4b[1]);
                _0x2e[atob(_0x3a4b[5])][atob(_0x3a4b[6])] = 'position:fixed;bottom:20px;right:20px;background:#2c3e50;color:#ecf0f1;text-align:right;padding:8px 16px;font-size:11px;font-family:Arial,sans-serif;z-index:9999;border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,0.2);letter-spacing:0.5px;';
            }
        })();
    </script>
</body>
</html>
